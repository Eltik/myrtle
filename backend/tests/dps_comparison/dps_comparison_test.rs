//! DPS Comparison Tests
//!
//! These tests compare Rust DPS calculations against the Python reference implementation.
//!
//! Run with: cargo test --test dps_comparison_test
//!
//! Note: The Python harness must be available in scripts/python_dps_harness.py

use std::io::Write;
use std::process::Command;

use backend::core::dps_calculator::operators::*;
use backend::core::dps_calculator::operator_data::OperatorData;
use backend::core::dps_calculator::operator_unit::{EnemyStats, OperatorParams};

/// Tolerance for DPS comparison (percentage difference allowed)
const TOLERANCE_PERCENT: f64 = 0.01; // 1%

/// Absolute tolerance for very small values
const TOLERANCE_ABSOLUTE: f64 = 1.0;

#[derive(Debug, serde::Deserialize)]
struct PythonDpsResult {
    operator: Option<String>,
    dps: Option<f64>,
    error: Option<String>,
    defense: Option<f64>,
    res: Option<f64>,
    atk: Option<f64>,
    attack_speed: Option<f64>,
    attack_interval: Option<f64>,
}

fn get_python_dps(operator: &str, defense: f64, res: f64, skill: i32, module: i32) -> Result<PythonDpsResult, String> {
    let harness_path = std::env::var("DPS_HARNESS_PATH")
        .unwrap_or_else(|_| "scripts/python_dps_harness.py".to_string());

    let config = serde_json::json!({
        "operator": operator,
        "defense": defense,
        "res": res,
        "skill": skill,
        "module": module,
    });

    let output = Command::new("python3")
        .arg(&harness_path)
        .arg("--batch")
        .stdin(std::process::Stdio::piped())
        .stdout(std::process::Stdio::piped())
        .stderr(std::process::Stdio::piped())
        .spawn()
        .and_then(|mut child| {
            if let Some(stdin) = child.stdin.as_mut() {
                writeln!(stdin, "{}", config.to_string())?;
            }
            child.wait_with_output()
        })
        .map_err(|e| format!("Failed to run Python harness: {}", e))?;

    if !output.status.success() {
        let stderr = String::from_utf8_lossy(&output.stderr);
        return Err(format!("Python harness failed: {}", stderr));
    }

    let stdout = String::from_utf8_lossy(&output.stdout);
    let result: PythonDpsResult = serde_json::from_str(stdout.trim())
        .map_err(|e| format!("Failed to parse Python output: {} (output: {})", e, stdout))?;

    if let Some(ref error) = result.error {
        return Err(error.clone());
    }

    Ok(result)
}

fn compare_dps(rust_dps: f64, python_dps: f64, test_name: &str) -> Result<(), String> {
    let diff = (rust_dps - python_dps).abs();
    let percent_diff = if python_dps.abs() > 0.01 {
        diff / python_dps.abs()
    } else {
        diff
    };

    if diff <= TOLERANCE_ABSOLUTE || percent_diff <= TOLERANCE_PERCENT {
        Ok(())
    } else {
        Err(format!(
            "{}: DPS mismatch - Rust: {:.2}, Python: {:.2}, Diff: {:.2} ({:.2}%)",
            test_name, rust_dps, python_dps, diff, percent_diff * 100.0
        ))
    }
}

/// Creates default operator params for testing
fn create_test_params(skill_index: i32, module_index: i32) -> OperatorParams {
    OperatorParams {
        skill_index,
        module_index,
        module_level: 3,
        potential: 6,
        elite: 2,
        level: 90,
        trust: 100,
        targets: 1,
        buff_atk: 0.0,
        buff_atk_flat: 0.0,
        attack_speed: 0.0,
        trait_damage: true,
        talent_damage: true,
        talent2_damage: true,
        skill_damage: true,
        module_damage: true,
    }
}

/// Creates enemy stats for testing
fn create_enemy_stats(defense: f64, res: f64) -> EnemyStats {
    EnemyStats { defense, res }
}

#[cfg(test)]
mod tests {
    use super::*;

    mod pepe {
        use super::*;

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Pepe", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Pepe::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Pepe s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Pepe", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Pepe::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Pepe s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Pepe", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Pepe::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Pepe s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Pepe", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Pepe::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Pepe s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Pepe", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Pepe::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Pepe s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Pepe", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Pepe::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Pepe s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Pepe", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Pepe::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Pepe s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Pepe", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Pepe::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Pepe s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Pepe", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Pepe::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Pepe s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Pepe", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Pepe::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Pepe s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Pepe", 0.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Pepe::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Pepe s3 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Pepe", 300.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Pepe::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Pepe s3 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Pepe", 0.0, 20.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Pepe::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Pepe s3 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Pepe", 500.0, 30.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Pepe::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Pepe s3 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Pepe", 1000.0, 50.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Pepe::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Pepe s3 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod dobermann {
        use super::*;

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Dobermann", 0.0, 0.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Dobermann::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Dobermann s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Dobermann", 300.0, 0.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Dobermann::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Dobermann s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Dobermann", 0.0, 20.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Dobermann::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Dobermann s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Dobermann", 500.0, 30.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Dobermann::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Dobermann s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Dobermann", 1000.0, 50.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Dobermann::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Dobermann s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Dobermann", 0.0, 0.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Dobermann::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Dobermann s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Dobermann", 300.0, 0.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Dobermann::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Dobermann s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Dobermann", 0.0, 20.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Dobermann::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Dobermann s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Dobermann", 500.0, 30.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Dobermann::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Dobermann s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Dobermann", 1000.0, 50.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Dobermann::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Dobermann s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod ebenholz {
        use super::*;

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ebenholz", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ebenholz::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ebenholz s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ebenholz", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ebenholz::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ebenholz s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ebenholz", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ebenholz::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ebenholz s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ebenholz", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ebenholz::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ebenholz s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ebenholz", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ebenholz::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ebenholz s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ebenholz", 0.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ebenholz::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ebenholz s3 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ebenholz", 300.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ebenholz::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ebenholz s3 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ebenholz", 0.0, 20.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ebenholz::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ebenholz s3 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ebenholz", 500.0, 30.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ebenholz::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ebenholz s3 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ebenholz", 1000.0, 50.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ebenholz::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ebenholz s3 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod windscoot {
        use super::*;

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Windscoot", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Windscoot::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Windscoot s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Windscoot", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Windscoot::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Windscoot s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Windscoot", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Windscoot::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Windscoot s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Windscoot", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Windscoot::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Windscoot s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Windscoot", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Windscoot::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Windscoot s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Windscoot", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Windscoot::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Windscoot s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Windscoot", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Windscoot::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Windscoot s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Windscoot", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Windscoot::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Windscoot s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Windscoot", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Windscoot::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Windscoot s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Windscoot", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Windscoot::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Windscoot s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod pith {
        use super::*;

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Pith", 0.0, 0.0, 0, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, -1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Pith::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Pith s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Pith", 300.0, 0.0, 0, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, -1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Pith::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Pith s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Pith", 0.0, 20.0, 0, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, -1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Pith::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Pith s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Pith", 500.0, 30.0, 0, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, -1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Pith::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Pith s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Pith", 1000.0, 50.0, 0, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, -1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Pith::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Pith s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod surfer {
        use super::*;

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Surfer", 0.0, 0.0, 0, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, -1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Surfer::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Surfer s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Surfer", 300.0, 0.0, 0, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, -1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Surfer::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Surfer s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Surfer", 0.0, 20.0, 0, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, -1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Surfer::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Surfer s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Surfer", 500.0, 30.0, 0, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, -1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Surfer::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Surfer s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Surfer", 1000.0, 50.0, 0, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, -1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Surfer::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Surfer s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Surfer", 0.0, 0.0, 1, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, -1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Surfer::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Surfer s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Surfer", 300.0, 0.0, 1, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, -1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Surfer::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Surfer s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Surfer", 0.0, 20.0, 1, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, -1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Surfer::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Surfer s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Surfer", 500.0, 30.0, 1, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, -1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Surfer::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Surfer s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Surfer", 1000.0, 50.0, 1, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, -1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Surfer::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Surfer s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod ashlock {
        use super::*;

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ashlock", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ashlock::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ashlock s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ashlock", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ashlock::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ashlock s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ashlock", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ashlock::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ashlock s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ashlock", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ashlock::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ashlock s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ashlock", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ashlock::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ashlock s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ashlock", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ashlock::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ashlock s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ashlock", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ashlock::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ashlock s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ashlock", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ashlock::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ashlock s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ashlock", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ashlock::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ashlock s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ashlock", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ashlock::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ashlock s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod narantuya {
        use super::*;

        #[test]
        fn test_s3_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Narantuya", 0.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Narantuya::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Narantuya s3 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Narantuya", 300.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Narantuya::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Narantuya s3 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Narantuya", 0.0, 20.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Narantuya::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Narantuya s3 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Narantuya", 500.0, 30.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Narantuya::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Narantuya s3 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Narantuya", 1000.0, 50.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Narantuya::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Narantuya s3 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Narantuya", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Narantuya::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Narantuya s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Narantuya", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Narantuya::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Narantuya s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Narantuya", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Narantuya::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Narantuya s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Narantuya", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Narantuya::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Narantuya s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Narantuya", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Narantuya::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Narantuya s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Narantuya", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Narantuya::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Narantuya s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Narantuya", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Narantuya::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Narantuya s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Narantuya", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Narantuya::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Narantuya s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Narantuya", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Narantuya::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Narantuya s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Narantuya", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Narantuya::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Narantuya s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod texas_alter {
        use super::*;

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("TexasAlter", 0.0, 0.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = TexasAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "TexasAlter s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("TexasAlter", 300.0, 0.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = TexasAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "TexasAlter s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("TexasAlter", 0.0, 20.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = TexasAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "TexasAlter s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("TexasAlter", 500.0, 30.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = TexasAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "TexasAlter s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("TexasAlter", 1000.0, 50.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = TexasAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "TexasAlter s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("TexasAlter", 0.0, 0.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = TexasAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "TexasAlter s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("TexasAlter", 300.0, 0.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = TexasAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "TexasAlter s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("TexasAlter", 0.0, 20.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = TexasAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "TexasAlter s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("TexasAlter", 500.0, 30.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = TexasAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "TexasAlter s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("TexasAlter", 1000.0, 50.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = TexasAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "TexasAlter s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("TexasAlter", 0.0, 0.0, 2, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 2);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = TexasAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "TexasAlter s3 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("TexasAlter", 300.0, 0.0, 2, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 2);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = TexasAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "TexasAlter s3 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("TexasAlter", 0.0, 20.0, 2, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 2);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = TexasAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "TexasAlter s3 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("TexasAlter", 500.0, 30.0, 2, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 2);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = TexasAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "TexasAlter s3 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("TexasAlter", 1000.0, 50.0, 2, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 2);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = TexasAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "TexasAlter s3 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod entelechia {
        use super::*;

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Entelechia", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Entelechia::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Entelechia s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Entelechia", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Entelechia::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Entelechia s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Entelechia", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Entelechia::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Entelechia s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Entelechia", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Entelechia::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Entelechia s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Entelechia", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Entelechia::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Entelechia s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Entelechia", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Entelechia::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Entelechia s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Entelechia", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Entelechia::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Entelechia s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Entelechia", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Entelechia::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Entelechia s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Entelechia", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Entelechia::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Entelechia s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Entelechia", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Entelechia::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Entelechia s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Entelechia", 0.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Entelechia::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Entelechia s3 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Entelechia", 300.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Entelechia::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Entelechia s3 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Entelechia", 0.0, 20.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Entelechia::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Entelechia s3 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Entelechia", 500.0, 30.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Entelechia::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Entelechia s3 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Entelechia", 1000.0, 50.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Entelechia::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Entelechia s3 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod stormeye {
        use super::*;

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Stormeye", 0.0, 0.0, 0, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, -1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Stormeye::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Stormeye s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Stormeye", 300.0, 0.0, 0, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, -1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Stormeye::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Stormeye s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Stormeye", 0.0, 20.0, 0, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, -1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Stormeye::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Stormeye s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Stormeye", 500.0, 30.0, 0, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, -1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Stormeye::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Stormeye s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Stormeye", 1000.0, 50.0, 0, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, -1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Stormeye::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Stormeye s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod mr_nothing {
        use super::*;

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("MrNothing", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = MrNothing::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "MrNothing s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("MrNothing", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = MrNothing::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "MrNothing s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("MrNothing", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = MrNothing::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "MrNothing s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("MrNothing", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = MrNothing::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "MrNothing s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("MrNothing", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = MrNothing::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "MrNothing s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("MrNothing", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = MrNothing::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "MrNothing s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("MrNothing", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = MrNothing::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "MrNothing s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("MrNothing", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = MrNothing::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "MrNothing s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("MrNothing", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = MrNothing::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "MrNothing s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("MrNothing", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = MrNothing::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "MrNothing s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod tachanka {
        use super::*;

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Tachanka", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Tachanka::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Tachanka s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Tachanka", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Tachanka::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Tachanka s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Tachanka", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Tachanka::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Tachanka s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Tachanka", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Tachanka::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Tachanka s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Tachanka", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Tachanka::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Tachanka s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Tachanka", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Tachanka::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Tachanka s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Tachanka", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Tachanka::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Tachanka s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Tachanka", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Tachanka::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Tachanka s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Tachanka", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Tachanka::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Tachanka s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Tachanka", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Tachanka::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Tachanka s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod erato {
        use super::*;

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Erato", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Erato::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Erato s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Erato", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Erato::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Erato s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Erato", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Erato::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Erato s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Erato", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Erato::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Erato s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Erato", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Erato::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Erato s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Erato", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Erato::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Erato s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Erato", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Erato::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Erato s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Erato", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Erato::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Erato s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Erato", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Erato::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Erato s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Erato", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Erato::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Erato s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod mostima {
        use super::*;

        #[test]
        fn test_s3_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Mostima", 0.0, 0.0, 2, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 2);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Mostima::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Mostima s3 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Mostima", 300.0, 0.0, 2, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 2);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Mostima::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Mostima s3 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Mostima", 0.0, 20.0, 2, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 2);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Mostima::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Mostima s3 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Mostima", 500.0, 30.0, 2, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 2);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Mostima::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Mostima s3 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Mostima", 1000.0, 50.0, 2, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 2);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Mostima::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Mostima s3 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Mostima", 0.0, 0.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Mostima::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Mostima s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Mostima", 300.0, 0.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Mostima::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Mostima s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Mostima", 0.0, 20.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Mostima::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Mostima s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Mostima", 500.0, 30.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Mostima::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Mostima s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Mostima", 1000.0, 50.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Mostima::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Mostima s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Mostima", 0.0, 0.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Mostima::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Mostima s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Mostima", 300.0, 0.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Mostima::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Mostima s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Mostima", 0.0, 20.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Mostima::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Mostima s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Mostima", 500.0, 30.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Mostima::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Mostima s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Mostima", 1000.0, 50.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Mostima::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Mostima s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod plume {
        use super::*;

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Plume", 0.0, 0.0, 0, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, -1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Plume::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Plume s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Plume", 300.0, 0.0, 0, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, -1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Plume::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Plume s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Plume", 0.0, 20.0, 0, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, -1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Plume::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Plume s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Plume", 500.0, 30.0, 0, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, -1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Plume::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Plume s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Plume", 1000.0, 50.0, 0, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, -1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Plume::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Plume s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod firewhistle {
        use super::*;

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Firewhistle", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Firewhistle::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Firewhistle s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Firewhistle", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Firewhistle::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Firewhistle s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Firewhistle", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Firewhistle::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Firewhistle s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Firewhistle", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Firewhistle::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Firewhistle s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Firewhistle", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Firewhistle::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Firewhistle s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Firewhistle", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Firewhistle::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Firewhistle s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Firewhistle", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Firewhistle::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Firewhistle s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Firewhistle", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Firewhistle::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Firewhistle s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Firewhistle", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Firewhistle::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Firewhistle s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Firewhistle", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Firewhistle::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Firewhistle s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod rosmontis {
        use super::*;

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Rosmontis", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Rosmontis::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Rosmontis s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Rosmontis", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Rosmontis::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Rosmontis s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Rosmontis", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Rosmontis::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Rosmontis s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Rosmontis", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Rosmontis::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Rosmontis s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Rosmontis", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Rosmontis::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Rosmontis s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Rosmontis", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Rosmontis::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Rosmontis s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Rosmontis", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Rosmontis::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Rosmontis s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Rosmontis", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Rosmontis::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Rosmontis s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Rosmontis", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Rosmontis::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Rosmontis s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Rosmontis", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Rosmontis::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Rosmontis s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Rosmontis", 0.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Rosmontis::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Rosmontis s3 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Rosmontis", 300.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Rosmontis::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Rosmontis s3 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Rosmontis", 0.0, 20.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Rosmontis::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Rosmontis s3 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Rosmontis", 500.0, 30.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Rosmontis::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Rosmontis s3 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Rosmontis", 1000.0, 50.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Rosmontis::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Rosmontis s3 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod vendela {
        use super::*;

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Vendela", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Vendela::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Vendela s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Vendela", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Vendela::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Vendela s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Vendela", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Vendela::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Vendela s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Vendela", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Vendela::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Vendela s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Vendela", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Vendela::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Vendela s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Vendela", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Vendela::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Vendela s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Vendela", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Vendela::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Vendela s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Vendela", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Vendela::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Vendela s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Vendela", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Vendela::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Vendela s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Vendela", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Vendela::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Vendela s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod defense {
        use super::*;

        #[test]
        fn test_base_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Defense", 0.0, 0.0, -1, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(-1, -1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Defense::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Defense base def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_base_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Defense", 300.0, 0.0, -1, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(-1, -1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Defense::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Defense base def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_base_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Defense", 0.0, 20.0, -1, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(-1, -1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Defense::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Defense base def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_base_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Defense", 500.0, 30.0, -1, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(-1, -1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Defense::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Defense base def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_base_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Defense", 1000.0, 50.0, -1, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(-1, -1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Defense::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Defense base def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod ascalon {
        use super::*;

        #[test]
        fn test_s3_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ascalon", 0.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ascalon::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ascalon s3 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ascalon", 300.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ascalon::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ascalon s3 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ascalon", 0.0, 20.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ascalon::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ascalon s3 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ascalon", 500.0, 30.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ascalon::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ascalon s3 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ascalon", 1000.0, 50.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ascalon::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ascalon s3 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ascalon", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ascalon::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ascalon s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ascalon", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ascalon::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ascalon s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ascalon", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ascalon::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ascalon s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ascalon", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ascalon::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ascalon s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ascalon", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ascalon::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ascalon s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ascalon", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ascalon::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ascalon s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ascalon", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ascalon::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ascalon s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ascalon", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ascalon::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ascalon s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ascalon", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ascalon::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ascalon s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ascalon", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ascalon::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ascalon s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod zuo_le {
        use super::*;

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("ZuoLe", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = ZuoLe::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "ZuoLe s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("ZuoLe", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = ZuoLe::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "ZuoLe s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("ZuoLe", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = ZuoLe::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "ZuoLe s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("ZuoLe", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = ZuoLe::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "ZuoLe s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("ZuoLe", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = ZuoLe::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "ZuoLe s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("ZuoLe", 0.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = ZuoLe::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "ZuoLe s3 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("ZuoLe", 300.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = ZuoLe::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "ZuoLe s3 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("ZuoLe", 0.0, 20.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = ZuoLe::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "ZuoLe s3 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("ZuoLe", 500.0, 30.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = ZuoLe::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "ZuoLe s3 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("ZuoLe", 1000.0, 50.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = ZuoLe::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "ZuoLe s3 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("ZuoLe", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = ZuoLe::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "ZuoLe s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("ZuoLe", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = ZuoLe::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "ZuoLe s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("ZuoLe", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = ZuoLe::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "ZuoLe s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("ZuoLe", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = ZuoLe::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "ZuoLe s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("ZuoLe", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = ZuoLe::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "ZuoLe s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod horn {
        use super::*;

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Horn", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Horn::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Horn s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Horn", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Horn::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Horn s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Horn", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Horn::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Horn s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Horn", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Horn::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Horn s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Horn", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Horn::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Horn s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Horn", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Horn::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Horn s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Horn", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Horn::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Horn s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Horn", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Horn::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Horn s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Horn", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Horn::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Horn s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Horn", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Horn::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Horn s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Horn", 0.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Horn::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Horn s3 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Horn", 300.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Horn::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Horn s3 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Horn", 0.0, 20.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Horn::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Horn s3 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Horn", 500.0, 30.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Horn::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Horn s3 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Horn", 1000.0, 50.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Horn::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Horn s3 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod bryophyta {
        use super::*;

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Bryophyta", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Bryophyta::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Bryophyta s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Bryophyta", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Bryophyta::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Bryophyta s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Bryophyta", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Bryophyta::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Bryophyta s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Bryophyta", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Bryophyta::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Bryophyta s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Bryophyta", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Bryophyta::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Bryophyta s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Bryophyta", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Bryophyta::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Bryophyta s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Bryophyta", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Bryophyta::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Bryophyta s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Bryophyta", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Bryophyta::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Bryophyta s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Bryophyta", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Bryophyta::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Bryophyta s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Bryophyta", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Bryophyta::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Bryophyta s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod lavaalt {
        use super::*;

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Lavaalt", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Lavaalt::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Lavaalt s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Lavaalt", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Lavaalt::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Lavaalt s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Lavaalt", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Lavaalt::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Lavaalt s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Lavaalt", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Lavaalt::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Lavaalt s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Lavaalt", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Lavaalt::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Lavaalt s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Lavaalt", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Lavaalt::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Lavaalt s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Lavaalt", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Lavaalt::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Lavaalt s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Lavaalt", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Lavaalt::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Lavaalt s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Lavaalt", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Lavaalt::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Lavaalt s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Lavaalt", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Lavaalt::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Lavaalt s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod shalem {
        use super::*;

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Shalem", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Shalem::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Shalem s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Shalem", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Shalem::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Shalem s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Shalem", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Shalem::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Shalem s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Shalem", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Shalem::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Shalem s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Shalem", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Shalem::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Shalem s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Shalem", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Shalem::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Shalem s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Shalem", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Shalem::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Shalem s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Shalem", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Shalem::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Shalem s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Shalem", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Shalem::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Shalem s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Shalem", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Shalem::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Shalem s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod hadiya {
        use super::*;

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Hadiya", 0.0, 0.0, 0, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, -1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Hadiya::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Hadiya s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Hadiya", 300.0, 0.0, 0, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, -1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Hadiya::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Hadiya s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Hadiya", 0.0, 20.0, 0, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, -1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Hadiya::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Hadiya s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Hadiya", 500.0, 30.0, 0, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, -1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Hadiya::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Hadiya s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Hadiya", 1000.0, 50.0, 0, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, -1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Hadiya::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Hadiya s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Hadiya", 0.0, 0.0, 1, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, -1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Hadiya::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Hadiya s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Hadiya", 300.0, 0.0, 1, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, -1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Hadiya::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Hadiya s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Hadiya", 0.0, 20.0, 1, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, -1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Hadiya::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Hadiya s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Hadiya", 500.0, 30.0, 1, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, -1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Hadiya::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Hadiya s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Hadiya", 1000.0, 50.0, 1, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, -1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Hadiya::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Hadiya s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod flametail {
        use super::*;

        #[test]
        fn test_s3_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Flametail", 0.0, 0.0, 2, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 2);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Flametail::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Flametail s3 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Flametail", 300.0, 0.0, 2, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 2);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Flametail::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Flametail s3 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Flametail", 0.0, 20.0, 2, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 2);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Flametail::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Flametail s3 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Flametail", 500.0, 30.0, 2, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 2);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Flametail::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Flametail s3 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Flametail", 1000.0, 50.0, 2, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 2);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Flametail::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Flametail s3 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Flametail", 0.0, 0.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Flametail::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Flametail s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Flametail", 300.0, 0.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Flametail::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Flametail s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Flametail", 0.0, 20.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Flametail::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Flametail s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Flametail", 500.0, 30.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Flametail::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Flametail s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Flametail", 1000.0, 50.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Flametail::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Flametail s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod civilight_eterna {
        use super::*;

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("CivilightEterna", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = CivilightEterna::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "CivilightEterna s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("CivilightEterna", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = CivilightEterna::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "CivilightEterna s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("CivilightEterna", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = CivilightEterna::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "CivilightEterna s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("CivilightEterna", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = CivilightEterna::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "CivilightEterna s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("CivilightEterna", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = CivilightEterna::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "CivilightEterna s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("CivilightEterna", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = CivilightEterna::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "CivilightEterna s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("CivilightEterna", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = CivilightEterna::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "CivilightEterna s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("CivilightEterna", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = CivilightEterna::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "CivilightEterna s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("CivilightEterna", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = CivilightEterna::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "CivilightEterna s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("CivilightEterna", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = CivilightEterna::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "CivilightEterna s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod tin_man {
        use super::*;

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("TinMan", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = TinMan::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "TinMan s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("TinMan", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = TinMan::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "TinMan s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("TinMan", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = TinMan::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "TinMan s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("TinMan", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = TinMan::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "TinMan s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("TinMan", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = TinMan::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "TinMan s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("TinMan", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = TinMan::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "TinMan s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("TinMan", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = TinMan::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "TinMan s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("TinMan", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = TinMan::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "TinMan s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("TinMan", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = TinMan::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "TinMan s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("TinMan", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = TinMan::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "TinMan s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod vanilla {
        use super::*;

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Vanilla", 0.0, 0.0, 0, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, -1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Vanilla::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Vanilla s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Vanilla", 300.0, 0.0, 0, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, -1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Vanilla::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Vanilla s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Vanilla", 0.0, 20.0, 0, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, -1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Vanilla::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Vanilla s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Vanilla", 500.0, 30.0, 0, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, -1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Vanilla::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Vanilla s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Vanilla", 1000.0, 50.0, 0, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, -1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Vanilla::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Vanilla s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod la_pluma {
        use super::*;

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("LaPluma", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = LaPluma::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "LaPluma s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("LaPluma", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = LaPluma::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "LaPluma s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("LaPluma", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = LaPluma::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "LaPluma s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("LaPluma", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = LaPluma::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "LaPluma s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("LaPluma", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = LaPluma::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "LaPluma s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("LaPluma", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = LaPluma::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "LaPluma s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("LaPluma", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = LaPluma::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "LaPluma s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("LaPluma", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = LaPluma::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "LaPluma s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("LaPluma", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = LaPluma::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "LaPluma s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("LaPluma", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = LaPluma::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "LaPluma s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod hibiscus {
        use super::*;

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Hibiscus", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Hibiscus::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Hibiscus s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Hibiscus", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Hibiscus::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Hibiscus s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Hibiscus", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Hibiscus::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Hibiscus s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Hibiscus", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Hibiscus::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Hibiscus s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Hibiscus", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Hibiscus::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Hibiscus s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Hibiscus", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Hibiscus::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Hibiscus s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Hibiscus", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Hibiscus::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Hibiscus s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Hibiscus", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Hibiscus::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Hibiscus s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Hibiscus", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Hibiscus::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Hibiscus s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Hibiscus", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Hibiscus::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Hibiscus s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod matoimaru {
        use super::*;

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Matoimaru", 0.0, 0.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Matoimaru::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Matoimaru s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Matoimaru", 300.0, 0.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Matoimaru::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Matoimaru s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Matoimaru", 0.0, 20.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Matoimaru::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Matoimaru s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Matoimaru", 500.0, 30.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Matoimaru::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Matoimaru s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Matoimaru", 1000.0, 50.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Matoimaru::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Matoimaru s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Matoimaru", 0.0, 0.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Matoimaru::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Matoimaru s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Matoimaru", 300.0, 0.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Matoimaru::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Matoimaru s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Matoimaru", 0.0, 20.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Matoimaru::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Matoimaru s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Matoimaru", 500.0, 30.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Matoimaru::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Matoimaru s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Matoimaru", 1000.0, 50.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Matoimaru::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Matoimaru s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod quartz {
        use super::*;

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Quartz", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Quartz::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Quartz s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Quartz", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Quartz::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Quartz s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Quartz", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Quartz::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Quartz s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Quartz", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Quartz::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Quartz s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Quartz", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Quartz::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Quartz s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Quartz", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Quartz::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Quartz s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Quartz", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Quartz::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Quartz s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Quartz", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Quartz::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Quartz s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Quartz", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Quartz::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Quartz s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Quartz", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Quartz::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Quartz s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod iana {
        use super::*;

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Iana", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Iana::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Iana s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Iana", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Iana::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Iana s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Iana", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Iana::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Iana s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Iana", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Iana::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Iana s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Iana", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Iana::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Iana s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Iana", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Iana::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Iana s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Iana", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Iana::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Iana s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Iana", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Iana::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Iana s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Iana", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Iana::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Iana s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Iana", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Iana::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Iana s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod kazemaru {
        use super::*;

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Kazemaru", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Kazemaru::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Kazemaru s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Kazemaru", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Kazemaru::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Kazemaru s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Kazemaru", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Kazemaru::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Kazemaru s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Kazemaru", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Kazemaru::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Kazemaru s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Kazemaru", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Kazemaru::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Kazemaru s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Kazemaru", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Kazemaru::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Kazemaru s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Kazemaru", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Kazemaru::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Kazemaru s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Kazemaru", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Kazemaru::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Kazemaru s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Kazemaru", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Kazemaru::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Kazemaru s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Kazemaru", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Kazemaru::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Kazemaru s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod sharp {
        use super::*;

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Sharp", 0.0, 0.0, 0, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, -1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Sharp::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Sharp s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Sharp", 300.0, 0.0, 0, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, -1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Sharp::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Sharp s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Sharp", 0.0, 20.0, 0, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, -1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Sharp::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Sharp s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Sharp", 500.0, 30.0, 0, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, -1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Sharp::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Sharp s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Sharp", 1000.0, 50.0, 0, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, -1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Sharp::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Sharp s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod snegurochka {
        use super::*;

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Snegurochka", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Snegurochka::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Snegurochka s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Snegurochka", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Snegurochka::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Snegurochka s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Snegurochka", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Snegurochka::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Snegurochka s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Snegurochka", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Snegurochka::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Snegurochka s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Snegurochka", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Snegurochka::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Snegurochka s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Snegurochka", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Snegurochka::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Snegurochka s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Snegurochka", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Snegurochka::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Snegurochka s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Snegurochka", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Snegurochka::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Snegurochka s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Snegurochka", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Snegurochka::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Snegurochka s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Snegurochka", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Snegurochka::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Snegurochka s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod irene {
        use super::*;

        #[test]
        fn test_s3_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Irene", 0.0, 0.0, 2, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 2);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Irene::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Irene s3 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Irene", 300.0, 0.0, 2, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 2);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Irene::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Irene s3 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Irene", 0.0, 20.0, 2, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 2);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Irene::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Irene s3 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Irene", 500.0, 30.0, 2, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 2);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Irene::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Irene s3 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Irene", 1000.0, 50.0, 2, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 2);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Irene::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Irene s3 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Irene", 0.0, 0.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Irene::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Irene s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Irene", 300.0, 0.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Irene::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Irene s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Irene", 0.0, 20.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Irene::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Irene s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Irene", 500.0, 30.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Irene::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Irene s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Irene", 1000.0, 50.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Irene::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Irene s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod fang_alter {
        use super::*;

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("FangAlter", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = FangAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "FangAlter s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("FangAlter", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = FangAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "FangAlter s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("FangAlter", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = FangAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "FangAlter s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("FangAlter", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = FangAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "FangAlter s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("FangAlter", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = FangAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "FangAlter s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("FangAlter", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = FangAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "FangAlter s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("FangAlter", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = FangAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "FangAlter s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("FangAlter", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = FangAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "FangAlter s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("FangAlter", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = FangAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "FangAlter s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("FangAlter", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = FangAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "FangAlter s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod carnelian {
        use super::*;

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Carnelian", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Carnelian::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Carnelian s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Carnelian", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Carnelian::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Carnelian s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Carnelian", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Carnelian::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Carnelian s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Carnelian", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Carnelian::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Carnelian s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Carnelian", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Carnelian::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Carnelian s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Carnelian", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Carnelian::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Carnelian s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Carnelian", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Carnelian::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Carnelian s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Carnelian", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Carnelian::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Carnelian s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Carnelian", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Carnelian::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Carnelian s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Carnelian", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Carnelian::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Carnelian s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Carnelian", 0.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Carnelian::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Carnelian s3 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Carnelian", 300.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Carnelian::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Carnelian s3 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Carnelian", 0.0, 20.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Carnelian::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Carnelian s3 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Carnelian", 500.0, 30.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Carnelian::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Carnelian s3 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Carnelian", 1000.0, 50.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Carnelian::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Carnelian s3 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod miss_christine {
        use super::*;

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("MissChristine", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = MissChristine::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "MissChristine s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("MissChristine", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = MissChristine::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "MissChristine s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("MissChristine", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = MissChristine::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "MissChristine s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("MissChristine", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = MissChristine::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "MissChristine s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("MissChristine", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = MissChristine::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "MissChristine s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("MissChristine", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = MissChristine::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "MissChristine s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("MissChristine", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = MissChristine::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "MissChristine s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("MissChristine", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = MissChristine::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "MissChristine s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("MissChristine", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = MissChristine::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "MissChristine s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("MissChristine", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = MissChristine::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "MissChristine s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod lutonada {
        use super::*;

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Lutonada", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Lutonada::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Lutonada s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Lutonada", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Lutonada::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Lutonada s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Lutonada", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Lutonada::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Lutonada s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Lutonada", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Lutonada::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Lutonada s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Lutonada", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Lutonada::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Lutonada s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Lutonada", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Lutonada::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Lutonada s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Lutonada", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Lutonada::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Lutonada s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Lutonada", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Lutonada::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Lutonada s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Lutonada", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Lutonada::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Lutonada s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Lutonada", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Lutonada::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Lutonada s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod mizuki {
        use super::*;

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Mizuki", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Mizuki::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Mizuki s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Mizuki", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Mizuki::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Mizuki s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Mizuki", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Mizuki::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Mizuki s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Mizuki", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Mizuki::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Mizuki s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Mizuki", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Mizuki::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Mizuki s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Mizuki", 0.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Mizuki::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Mizuki s3 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Mizuki", 300.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Mizuki::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Mizuki s3 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Mizuki", 0.0, 20.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Mizuki::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Mizuki s3 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Mizuki", 500.0, 30.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Mizuki::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Mizuki s3 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Mizuki", 1000.0, 50.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Mizuki::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Mizuki s3 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Mizuki", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Mizuki::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Mizuki s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Mizuki", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Mizuki::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Mizuki s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Mizuki", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Mizuki::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Mizuki s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Mizuki", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Mizuki::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Mizuki s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Mizuki", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Mizuki::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Mizuki s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod saga {
        use super::*;

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Saga", 0.0, 0.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Saga::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Saga s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Saga", 300.0, 0.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Saga::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Saga s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Saga", 0.0, 20.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Saga::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Saga s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Saga", 500.0, 30.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Saga::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Saga s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Saga", 1000.0, 50.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Saga::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Saga s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Saga", 0.0, 0.0, 2, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 2);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Saga::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Saga s3 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Saga", 300.0, 0.0, 2, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 2);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Saga::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Saga s3 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Saga", 0.0, 20.0, 2, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 2);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Saga::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Saga s3 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Saga", 500.0, 30.0, 2, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 2);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Saga::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Saga s3 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Saga", 1000.0, 50.0, 2, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 2);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Saga::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Saga s3 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Saga", 0.0, 0.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Saga::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Saga s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Saga", 300.0, 0.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Saga::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Saga s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Saga", 0.0, 20.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Saga::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Saga s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Saga", 500.0, 30.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Saga::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Saga s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Saga", 1000.0, 50.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Saga::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Saga s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod kafka {
        use super::*;

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Kafka", 0.0, 0.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Kafka::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Kafka s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Kafka", 300.0, 0.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Kafka::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Kafka s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Kafka", 0.0, 20.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Kafka::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Kafka s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Kafka", 500.0, 30.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Kafka::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Kafka s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Kafka", 1000.0, 50.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Kafka::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Kafka s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Kafka", 0.0, 0.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Kafka::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Kafka s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Kafka", 300.0, 0.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Kafka::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Kafka s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Kafka", 0.0, 20.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Kafka::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Kafka s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Kafka", 500.0, 30.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Kafka::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Kafka s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Kafka", 1000.0, 50.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Kafka::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Kafka s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod folinic {
        use super::*;

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Folinic", 0.0, 0.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Folinic::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Folinic s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Folinic", 300.0, 0.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Folinic::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Folinic s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Folinic", 0.0, 20.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Folinic::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Folinic s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Folinic", 500.0, 30.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Folinic::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Folinic s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Folinic", 1000.0, 50.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Folinic::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Folinic s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod suzuran {
        use super::*;

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Suzuran", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Suzuran::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Suzuran s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Suzuran", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Suzuran::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Suzuran s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Suzuran", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Suzuran::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Suzuran s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Suzuran", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Suzuran::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Suzuran s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Suzuran", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Suzuran::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Suzuran s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Suzuran", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Suzuran::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Suzuran s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Suzuran", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Suzuran::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Suzuran s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Suzuran", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Suzuran::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Suzuran s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Suzuran", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Suzuran::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Suzuran s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Suzuran", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Suzuran::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Suzuran s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Suzuran", 0.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Suzuran::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Suzuran s3 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Suzuran", 300.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Suzuran::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Suzuran s3 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Suzuran", 0.0, 20.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Suzuran::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Suzuran s3 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Suzuran", 500.0, 30.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Suzuran::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Suzuran s3 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Suzuran", 1000.0, 50.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Suzuran::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Suzuran s3 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod click {
        use super::*;

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Click", 0.0, 0.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Click::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Click s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Click", 300.0, 0.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Click::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Click s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Click", 0.0, 20.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Click::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Click s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Click", 500.0, 30.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Click::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Click s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Click", 1000.0, 50.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Click::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Click s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Click", 0.0, 0.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Click::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Click s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Click", 300.0, 0.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Click::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Click s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Click", 0.0, 20.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Click::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Click s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Click", 500.0, 30.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Click::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Click s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Click", 1000.0, 50.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Click::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Click s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod yato_alter {
        use super::*;

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("YatoAlter", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = YatoAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "YatoAlter s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("YatoAlter", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = YatoAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "YatoAlter s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("YatoAlter", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = YatoAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "YatoAlter s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("YatoAlter", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = YatoAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "YatoAlter s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("YatoAlter", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = YatoAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "YatoAlter s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("YatoAlter", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = YatoAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "YatoAlter s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("YatoAlter", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = YatoAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "YatoAlter s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("YatoAlter", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = YatoAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "YatoAlter s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("YatoAlter", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = YatoAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "YatoAlter s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("YatoAlter", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = YatoAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "YatoAlter s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("YatoAlter", 0.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = YatoAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "YatoAlter s3 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("YatoAlter", 300.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = YatoAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "YatoAlter s3 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("YatoAlter", 0.0, 20.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = YatoAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "YatoAlter s3 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("YatoAlter", 500.0, 30.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = YatoAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "YatoAlter s3 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("YatoAlter", 1000.0, 50.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = YatoAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "YatoAlter s3 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod viviana {
        use super::*;

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Viviana", 0.0, 0.0, 0, 3) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 3);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Viviana::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Viviana s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Viviana", 300.0, 0.0, 0, 3) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 3);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Viviana::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Viviana s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Viviana", 0.0, 20.0, 0, 3) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 3);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Viviana::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Viviana s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Viviana", 500.0, 30.0, 0, 3) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 3);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Viviana::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Viviana s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Viviana", 1000.0, 50.0, 0, 3) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 3);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Viviana::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Viviana s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Viviana", 0.0, 0.0, 2, 3) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 3);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Viviana::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Viviana s3 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Viviana", 300.0, 0.0, 2, 3) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 3);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Viviana::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Viviana s3 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Viviana", 0.0, 20.0, 2, 3) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 3);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Viviana::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Viviana s3 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Viviana", 500.0, 30.0, 2, 3) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 3);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Viviana::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Viviana s3 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Viviana", 1000.0, 50.0, 2, 3) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 3);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Viviana::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Viviana s3 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Viviana", 0.0, 0.0, 1, 3) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 3);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Viviana::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Viviana s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Viviana", 300.0, 0.0, 1, 3) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 3);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Viviana::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Viviana s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Viviana", 0.0, 20.0, 1, 3) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 3);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Viviana::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Viviana s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Viviana", 500.0, 30.0, 1, 3) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 3);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Viviana::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Viviana s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Viviana", 1000.0, 50.0, 1, 3) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 3);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Viviana::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Viviana s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod lee {
        use super::*;

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Lee", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Lee::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Lee s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Lee", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Lee::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Lee s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Lee", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Lee::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Lee s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Lee", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Lee::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Lee s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Lee", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Lee::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Lee s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Lee", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Lee::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Lee s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Lee", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Lee::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Lee s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Lee", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Lee::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Lee s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Lee", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Lee::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Lee s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Lee", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Lee::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Lee s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Lee", 0.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Lee::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Lee s3 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Lee", 300.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Lee::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Lee s3 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Lee", 0.0, 20.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Lee::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Lee s3 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Lee", 500.0, 30.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Lee::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Lee s3 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Lee", 1000.0, 50.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Lee::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Lee s3 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod durnar {
        use super::*;

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Durnar", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Durnar::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Durnar s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Durnar", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Durnar::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Durnar s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Durnar", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Durnar::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Durnar s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Durnar", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Durnar::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Durnar s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Durnar", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Durnar::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Durnar s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Durnar", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Durnar::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Durnar s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Durnar", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Durnar::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Durnar s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Durnar", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Durnar::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Durnar s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Durnar", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Durnar::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Durnar s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Durnar", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Durnar::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Durnar s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod morgan {
        use super::*;

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Morgan", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Morgan::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Morgan s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Morgan", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Morgan::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Morgan s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Morgan", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Morgan::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Morgan s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Morgan", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Morgan::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Morgan s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Morgan", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Morgan::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Morgan s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Morgan", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Morgan::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Morgan s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Morgan", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Morgan::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Morgan s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Morgan", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Morgan::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Morgan s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Morgan", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Morgan::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Morgan s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Morgan", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Morgan::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Morgan s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod absinthe {
        use super::*;

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Absinthe", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Absinthe::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Absinthe s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Absinthe", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Absinthe::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Absinthe s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Absinthe", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Absinthe::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Absinthe s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Absinthe", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Absinthe::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Absinthe s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Absinthe", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Absinthe::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Absinthe s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Absinthe", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Absinthe::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Absinthe s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Absinthe", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Absinthe::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Absinthe s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Absinthe", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Absinthe::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Absinthe s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Absinthe", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Absinthe::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Absinthe s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Absinthe", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Absinthe::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Absinthe s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod aciddrop {
        use super::*;

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Aciddrop", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Aciddrop::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Aciddrop s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Aciddrop", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Aciddrop::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Aciddrop s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Aciddrop", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Aciddrop::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Aciddrop s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Aciddrop", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Aciddrop::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Aciddrop s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Aciddrop", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Aciddrop::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Aciddrop s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Aciddrop", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Aciddrop::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Aciddrop s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Aciddrop", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Aciddrop::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Aciddrop s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Aciddrop", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Aciddrop::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Aciddrop s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Aciddrop", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Aciddrop::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Aciddrop s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Aciddrop", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Aciddrop::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Aciddrop s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod midnight {
        use super::*;

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Midnight", 0.0, 0.0, 0, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, -1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Midnight::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Midnight s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Midnight", 300.0, 0.0, 0, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, -1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Midnight::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Midnight s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Midnight", 0.0, 20.0, 0, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, -1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Midnight::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Midnight s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Midnight", 500.0, 30.0, 0, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, -1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Midnight::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Midnight s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Midnight", 1000.0, 50.0, 0, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, -1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Midnight::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Midnight s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod diamante {
        use super::*;

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Diamante", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Diamante::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Diamante s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Diamante", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Diamante::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Diamante s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Diamante", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Diamante::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Diamante s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Diamante", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Diamante::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Diamante s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Diamante", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Diamante::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Diamante s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Diamante", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Diamante::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Diamante s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Diamante", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Diamante::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Diamante s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Diamante", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Diamante::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Diamante s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Diamante", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Diamante::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Diamante s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Diamante", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Diamante::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Diamante s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod nearl_alter {
        use super::*;

        #[test]
        fn test_s3_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("NearlAlter", 0.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = NearlAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "NearlAlter s3 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("NearlAlter", 300.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = NearlAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "NearlAlter s3 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("NearlAlter", 0.0, 20.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = NearlAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "NearlAlter s3 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("NearlAlter", 500.0, 30.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = NearlAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "NearlAlter s3 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("NearlAlter", 1000.0, 50.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = NearlAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "NearlAlter s3 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("NearlAlter", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = NearlAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "NearlAlter s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("NearlAlter", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = NearlAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "NearlAlter s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("NearlAlter", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = NearlAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "NearlAlter s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("NearlAlter", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = NearlAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "NearlAlter s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("NearlAlter", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = NearlAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "NearlAlter s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("NearlAlter", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = NearlAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "NearlAlter s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("NearlAlter", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = NearlAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "NearlAlter s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("NearlAlter", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = NearlAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "NearlAlter s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("NearlAlter", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = NearlAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "NearlAlter s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("NearlAlter", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = NearlAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "NearlAlter s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod astesia {
        use super::*;

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Astesia", 0.0, 0.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Astesia::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Astesia s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Astesia", 300.0, 0.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Astesia::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Astesia s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Astesia", 0.0, 20.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Astesia::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Astesia s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Astesia", 500.0, 30.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Astesia::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Astesia s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Astesia", 1000.0, 50.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Astesia::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Astesia s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Astesia", 0.0, 0.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Astesia::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Astesia s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Astesia", 300.0, 0.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Astesia::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Astesia s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Astesia", 0.0, 20.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Astesia::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Astesia s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Astesia", 500.0, 30.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Astesia::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Astesia s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Astesia", 1000.0, 50.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Astesia::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Astesia s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod wakaba_mutsumi {
        use super::*;

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("WakabaMutsumi", 0.0, 0.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = WakabaMutsumi::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "WakabaMutsumi s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("WakabaMutsumi", 300.0, 0.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = WakabaMutsumi::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "WakabaMutsumi s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("WakabaMutsumi", 0.0, 20.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = WakabaMutsumi::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "WakabaMutsumi s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("WakabaMutsumi", 500.0, 30.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = WakabaMutsumi::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "WakabaMutsumi s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("WakabaMutsumi", 1000.0, 50.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = WakabaMutsumi::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "WakabaMutsumi s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("WakabaMutsumi", 0.0, 0.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = WakabaMutsumi::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "WakabaMutsumi s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("WakabaMutsumi", 300.0, 0.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = WakabaMutsumi::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "WakabaMutsumi s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("WakabaMutsumi", 0.0, 20.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = WakabaMutsumi::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "WakabaMutsumi s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("WakabaMutsumi", 500.0, 30.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = WakabaMutsumi::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "WakabaMutsumi s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("WakabaMutsumi", 1000.0, 50.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = WakabaMutsumi::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "WakabaMutsumi s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod jaye {
        use super::*;

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Jaye", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Jaye::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Jaye s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Jaye", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Jaye::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Jaye s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Jaye", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Jaye::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Jaye s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Jaye", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Jaye::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Jaye s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Jaye", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Jaye::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Jaye s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Jaye", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Jaye::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Jaye s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Jaye", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Jaye::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Jaye s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Jaye", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Jaye::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Jaye s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Jaye", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Jaye::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Jaye s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Jaye", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Jaye::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Jaye s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod arene {
        use super::*;

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Arene", 0.0, 0.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Arene::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Arene s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Arene", 300.0, 0.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Arene::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Arene s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Arene", 0.0, 20.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Arene::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Arene s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Arene", 500.0, 30.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Arene::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Arene s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Arene", 1000.0, 50.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Arene::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Arene s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Arene", 0.0, 0.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Arene::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Arene s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Arene", 300.0, 0.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Arene::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Arene s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Arene", 0.0, 20.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Arene::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Arene s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Arene", 500.0, 30.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Arene::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Arene s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Arene", 1000.0, 50.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Arene::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Arene s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod utage {
        use super::*;

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Utage", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Utage::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Utage s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Utage", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Utage::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Utage s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Utage", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Utage::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Utage s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Utage", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Utage::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Utage s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Utage", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Utage::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Utage s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Utage", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Utage::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Utage s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Utage", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Utage::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Utage s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Utage", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Utage::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Utage s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Utage", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Utage::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Utage s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Utage", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Utage::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Utage s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod pinecone {
        use super::*;

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Pinecone", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Pinecone::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Pinecone s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Pinecone", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Pinecone::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Pinecone s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Pinecone", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Pinecone::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Pinecone s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Pinecone", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Pinecone::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Pinecone s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Pinecone", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Pinecone::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Pinecone s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Pinecone", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Pinecone::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Pinecone s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Pinecone", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Pinecone::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Pinecone s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Pinecone", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Pinecone::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Pinecone s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Pinecone", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Pinecone::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Pinecone s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Pinecone", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Pinecone::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Pinecone s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod archetto {
        use super::*;

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Archetto", 0.0, 0.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Archetto::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Archetto s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Archetto", 300.0, 0.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Archetto::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Archetto s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Archetto", 0.0, 20.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Archetto::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Archetto s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Archetto", 500.0, 30.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Archetto::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Archetto s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Archetto", 1000.0, 50.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Archetto::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Archetto s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Archetto", 0.0, 0.0, 2, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 2);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Archetto::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Archetto s3 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Archetto", 300.0, 0.0, 2, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 2);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Archetto::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Archetto s3 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Archetto", 0.0, 20.0, 2, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 2);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Archetto::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Archetto s3 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Archetto", 500.0, 30.0, 2, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 2);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Archetto::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Archetto s3 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Archetto", 1000.0, 50.0, 2, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 2);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Archetto::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Archetto s3 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Archetto", 0.0, 0.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Archetto::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Archetto s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Archetto", 300.0, 0.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Archetto::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Archetto s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Archetto", 0.0, 20.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Archetto::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Archetto s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Archetto", 500.0, 30.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Archetto::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Archetto s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Archetto", 1000.0, 50.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Archetto::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Archetto s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod hellagur {
        use super::*;

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Hellagur", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Hellagur::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Hellagur s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Hellagur", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Hellagur::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Hellagur s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Hellagur", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Hellagur::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Hellagur s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Hellagur", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Hellagur::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Hellagur s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Hellagur", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Hellagur::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Hellagur s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Hellagur", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Hellagur::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Hellagur s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Hellagur", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Hellagur::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Hellagur s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Hellagur", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Hellagur::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Hellagur s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Hellagur", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Hellagur::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Hellagur s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Hellagur", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Hellagur::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Hellagur s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Hellagur", 0.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Hellagur::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Hellagur s3 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Hellagur", 300.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Hellagur::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Hellagur s3 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Hellagur", 0.0, 20.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Hellagur::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Hellagur s3 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Hellagur", 500.0, 30.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Hellagur::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Hellagur s3 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Hellagur", 1000.0, 50.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Hellagur::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Hellagur s3 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod mudrock {
        use super::*;

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Mudrock", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Mudrock::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Mudrock s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Mudrock", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Mudrock::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Mudrock s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Mudrock", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Mudrock::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Mudrock s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Mudrock", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Mudrock::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Mudrock s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Mudrock", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Mudrock::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Mudrock s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Mudrock", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Mudrock::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Mudrock s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Mudrock", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Mudrock::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Mudrock s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Mudrock", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Mudrock::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Mudrock s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Mudrock", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Mudrock::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Mudrock s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Mudrock", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Mudrock::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Mudrock s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Mudrock", 0.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Mudrock::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Mudrock s3 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Mudrock", 300.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Mudrock::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Mudrock s3 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Mudrock", 0.0, 20.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Mudrock::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Mudrock s3 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Mudrock", 500.0, 30.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Mudrock::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Mudrock s3 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Mudrock", 1000.0, 50.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Mudrock::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Mudrock s3 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod savage {
        use super::*;

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Savage", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Savage::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Savage s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Savage", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Savage::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Savage s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Savage", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Savage::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Savage s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Savage", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Savage::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Savage s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Savage", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Savage::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Savage s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod lappland {
        use super::*;

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Lappland", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Lappland::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Lappland s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Lappland", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Lappland::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Lappland s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Lappland", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Lappland::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Lappland s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Lappland", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Lappland::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Lappland s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Lappland", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Lappland::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Lappland s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Lappland", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Lappland::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Lappland s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Lappland", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Lappland::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Lappland s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Lappland", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Lappland::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Lappland s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Lappland", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Lappland::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Lappland s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Lappland", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Lappland::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Lappland s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod may {
        use super::*;

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("May", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = May::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "May s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("May", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = May::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "May s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("May", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = May::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "May s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("May", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = May::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "May s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("May", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = May::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "May s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("May", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = May::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "May s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("May", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = May::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "May s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("May", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = May::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "May s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("May", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = May::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "May s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("May", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = May::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "May s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod vina {
        use super::*;

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Vina", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Vina::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Vina s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Vina", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Vina::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Vina s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Vina", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Vina::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Vina s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Vina", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Vina::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Vina s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Vina", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Vina::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Vina s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Vina", 0.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Vina::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Vina s3 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Vina", 300.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Vina::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Vina s3 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Vina", 0.0, 20.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Vina::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Vina s3 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Vina", 500.0, 30.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Vina::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Vina s3 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Vina", 1000.0, 50.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Vina::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Vina s3 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Vina", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Vina::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Vina s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Vina", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Vina::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Vina s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Vina", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Vina::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Vina s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Vina", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Vina::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Vina s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Vina", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Vina::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Vina s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod pallas {
        use super::*;

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Pallas", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Pallas::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Pallas s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Pallas", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Pallas::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Pallas s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Pallas", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Pallas::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Pallas s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Pallas", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Pallas::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Pallas s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Pallas", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Pallas::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Pallas s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Pallas", 0.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Pallas::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Pallas s3 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Pallas", 300.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Pallas::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Pallas s3 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Pallas", 0.0, 20.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Pallas::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Pallas s3 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Pallas", 500.0, 30.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Pallas::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Pallas s3 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Pallas", 1000.0, 50.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Pallas::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Pallas s3 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Pallas", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Pallas::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Pallas s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Pallas", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Pallas::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Pallas s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Pallas", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Pallas::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Pallas s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Pallas", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Pallas::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Pallas s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Pallas", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Pallas::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Pallas s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod penance {
        use super::*;

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Penance", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Penance::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Penance s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Penance", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Penance::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Penance s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Penance", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Penance::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Penance s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Penance", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Penance::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Penance s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Penance", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Penance::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Penance s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Penance", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Penance::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Penance s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Penance", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Penance::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Penance s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Penance", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Penance::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Penance s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Penance", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Penance::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Penance s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Penance", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Penance::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Penance s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Penance", 0.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Penance::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Penance s3 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Penance", 300.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Penance::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Penance s3 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Penance", 0.0, 20.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Penance::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Penance s3 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Penance", 500.0, 30.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Penance::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Penance s3 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Penance", 1000.0, 50.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Penance::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Penance s3 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod tippi {
        use super::*;

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Tippi", 0.0, 0.0, 1, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, -1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Tippi::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Tippi s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Tippi", 300.0, 0.0, 1, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, -1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Tippi::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Tippi s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Tippi", 0.0, 20.0, 1, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, -1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Tippi::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Tippi s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Tippi", 500.0, 30.0, 1, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, -1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Tippi::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Tippi s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Tippi", 1000.0, 50.0, 1, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, -1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Tippi::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Tippi s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Tippi", 0.0, 0.0, 0, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, -1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Tippi::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Tippi s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Tippi", 300.0, 0.0, 0, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, -1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Tippi::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Tippi s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Tippi", 0.0, 20.0, 0, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, -1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Tippi::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Tippi s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Tippi", 500.0, 30.0, 0, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, -1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Tippi::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Tippi s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Tippi", 1000.0, 50.0, 0, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, -1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Tippi::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Tippi s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod pozemka {
        use super::*;

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Pozemka", 0.0, 0.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Pozemka::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Pozemka s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Pozemka", 300.0, 0.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Pozemka::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Pozemka s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Pozemka", 0.0, 20.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Pozemka::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Pozemka s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Pozemka", 500.0, 30.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Pozemka::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Pozemka s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Pozemka", 1000.0, 50.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Pozemka::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Pozemka s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Pozemka", 0.0, 0.0, 2, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 2);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Pozemka::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Pozemka s3 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Pozemka", 300.0, 0.0, 2, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 2);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Pozemka::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Pozemka s3 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Pozemka", 0.0, 20.0, 2, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 2);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Pozemka::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Pozemka s3 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Pozemka", 500.0, 30.0, 2, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 2);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Pozemka::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Pozemka s3 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Pozemka", 1000.0, 50.0, 2, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 2);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Pozemka::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Pozemka s3 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod hoshiguma {
        use super::*;

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Hoshiguma", 0.0, 0.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Hoshiguma::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Hoshiguma s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Hoshiguma", 300.0, 0.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Hoshiguma::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Hoshiguma s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Hoshiguma", 0.0, 20.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Hoshiguma::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Hoshiguma s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Hoshiguma", 500.0, 30.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Hoshiguma::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Hoshiguma s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Hoshiguma", 1000.0, 50.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Hoshiguma::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Hoshiguma s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Hoshiguma", 0.0, 0.0, 2, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 2);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Hoshiguma::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Hoshiguma s3 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Hoshiguma", 300.0, 0.0, 2, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 2);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Hoshiguma::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Hoshiguma s3 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Hoshiguma", 0.0, 20.0, 2, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 2);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Hoshiguma::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Hoshiguma s3 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Hoshiguma", 500.0, 30.0, 2, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 2);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Hoshiguma::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Hoshiguma s3 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Hoshiguma", 1000.0, 50.0, 2, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 2);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Hoshiguma::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Hoshiguma s3 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Hoshiguma", 0.0, 0.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Hoshiguma::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Hoshiguma s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Hoshiguma", 300.0, 0.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Hoshiguma::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Hoshiguma s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Hoshiguma", 0.0, 20.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Hoshiguma::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Hoshiguma s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Hoshiguma", 500.0, 30.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Hoshiguma::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Hoshiguma s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Hoshiguma", 1000.0, 50.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Hoshiguma::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Hoshiguma s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod ethan {
        use super::*;

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ethan", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ethan::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ethan s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ethan", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ethan::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ethan s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ethan", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ethan::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ethan s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ethan", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ethan::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ethan s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ethan", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ethan::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ethan s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ethan", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ethan::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ethan s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ethan", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ethan::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ethan s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ethan", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ethan::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ethan s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ethan", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ethan::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ethan s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ethan", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ethan::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ethan s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod franka {
        use super::*;

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Franka", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Franka::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Franka s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Franka", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Franka::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Franka s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Franka", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Franka::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Franka s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Franka", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Franka::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Franka s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Franka", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Franka::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Franka s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Franka", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Franka::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Franka s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Franka", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Franka::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Franka s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Franka", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Franka::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Franka s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Franka", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Franka::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Franka s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Franka", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Franka::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Franka s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod ayerscarpe {
        use super::*;

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ayerscarpe", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ayerscarpe::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ayerscarpe s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ayerscarpe", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ayerscarpe::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ayerscarpe s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ayerscarpe", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ayerscarpe::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ayerscarpe s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ayerscarpe", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ayerscarpe::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ayerscarpe s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ayerscarpe", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ayerscarpe::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ayerscarpe s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ayerscarpe", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ayerscarpe::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ayerscarpe s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ayerscarpe", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ayerscarpe::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ayerscarpe s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ayerscarpe", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ayerscarpe::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ayerscarpe s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ayerscarpe", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ayerscarpe::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ayerscarpe s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ayerscarpe", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ayerscarpe::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ayerscarpe s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod gracebearer {
        use super::*;

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Gracebearer", 0.0, 0.0, 0, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, -1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Gracebearer::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Gracebearer s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Gracebearer", 300.0, 0.0, 0, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, -1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Gracebearer::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Gracebearer s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Gracebearer", 0.0, 20.0, 0, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, -1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Gracebearer::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Gracebearer s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Gracebearer", 500.0, 30.0, 0, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, -1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Gracebearer::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Gracebearer s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Gracebearer", 1000.0, 50.0, 0, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, -1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Gracebearer::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Gracebearer s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Gracebearer", 0.0, 0.0, 1, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, -1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Gracebearer::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Gracebearer s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Gracebearer", 300.0, 0.0, 1, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, -1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Gracebearer::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Gracebearer s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Gracebearer", 0.0, 20.0, 1, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, -1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Gracebearer::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Gracebearer s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Gracebearer", 500.0, 30.0, 1, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, -1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Gracebearer::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Gracebearer s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Gracebearer", 1000.0, 50.0, 1, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, -1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Gracebearer::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Gracebearer s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod highmore {
        use super::*;

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Highmore", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Highmore::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Highmore s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Highmore", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Highmore::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Highmore s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Highmore", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Highmore::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Highmore s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Highmore", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Highmore::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Highmore s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Highmore", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Highmore::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Highmore s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Highmore", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Highmore::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Highmore s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Highmore", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Highmore::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Highmore s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Highmore", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Highmore::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Highmore s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Highmore", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Highmore::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Highmore s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Highmore", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Highmore::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Highmore s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod luo_xiaohei {
        use super::*;

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("LuoXiaohei", 0.0, 0.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = LuoXiaohei::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "LuoXiaohei s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("LuoXiaohei", 300.0, 0.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = LuoXiaohei::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "LuoXiaohei s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("LuoXiaohei", 0.0, 20.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = LuoXiaohei::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "LuoXiaohei s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("LuoXiaohei", 500.0, 30.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = LuoXiaohei::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "LuoXiaohei s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("LuoXiaohei", 1000.0, 50.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = LuoXiaohei::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "LuoXiaohei s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("LuoXiaohei", 0.0, 0.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = LuoXiaohei::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "LuoXiaohei s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("LuoXiaohei", 300.0, 0.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = LuoXiaohei::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "LuoXiaohei s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("LuoXiaohei", 0.0, 20.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = LuoXiaohei::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "LuoXiaohei s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("LuoXiaohei", 500.0, 30.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = LuoXiaohei::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "LuoXiaohei s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("LuoXiaohei", 1000.0, 50.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = LuoXiaohei::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "LuoXiaohei s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod hoshiguma_alter {
        use super::*;

        #[test]
        fn test_s3_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("HoshigumaAlter", 0.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = HoshigumaAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "HoshigumaAlter s3 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("HoshigumaAlter", 300.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = HoshigumaAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "HoshigumaAlter s3 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("HoshigumaAlter", 0.0, 20.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = HoshigumaAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "HoshigumaAlter s3 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("HoshigumaAlter", 500.0, 30.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = HoshigumaAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "HoshigumaAlter s3 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("HoshigumaAlter", 1000.0, 50.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = HoshigumaAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "HoshigumaAlter s3 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("HoshigumaAlter", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = HoshigumaAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "HoshigumaAlter s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("HoshigumaAlter", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = HoshigumaAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "HoshigumaAlter s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("HoshigumaAlter", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = HoshigumaAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "HoshigumaAlter s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("HoshigumaAlter", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = HoshigumaAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "HoshigumaAlter s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("HoshigumaAlter", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = HoshigumaAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "HoshigumaAlter s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod vulcan {
        use super::*;

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Vulcan", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Vulcan::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Vulcan s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Vulcan", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Vulcan::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Vulcan s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Vulcan", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Vulcan::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Vulcan s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Vulcan", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Vulcan::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Vulcan s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Vulcan", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Vulcan::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Vulcan s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Vulcan", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Vulcan::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Vulcan s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Vulcan", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Vulcan::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Vulcan s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Vulcan", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Vulcan::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Vulcan s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Vulcan", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Vulcan::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Vulcan s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Vulcan", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Vulcan::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Vulcan s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod grani {
        use super::*;

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Grani", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Grani::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Grani s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Grani", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Grani::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Grani s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Grani", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Grani::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Grani s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Grani", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Grani::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Grani s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Grani", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Grani::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Grani s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Grani", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Grani::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Grani s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Grani", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Grani::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Grani s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Grani", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Grani::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Grani s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Grani", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Grani::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Grani s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Grani", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Grani::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Grani s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod chen_alter {
        use super::*;

        #[test]
        fn test_s3_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("ChenAlter", 0.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = ChenAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "ChenAlter s3 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("ChenAlter", 300.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = ChenAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "ChenAlter s3 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("ChenAlter", 0.0, 20.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = ChenAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "ChenAlter s3 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("ChenAlter", 500.0, 30.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = ChenAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "ChenAlter s3 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("ChenAlter", 1000.0, 50.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = ChenAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "ChenAlter s3 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("ChenAlter", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = ChenAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "ChenAlter s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("ChenAlter", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = ChenAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "ChenAlter s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("ChenAlter", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = ChenAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "ChenAlter s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("ChenAlter", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = ChenAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "ChenAlter s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("ChenAlter", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = ChenAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "ChenAlter s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod totter {
        use super::*;

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Totter", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Totter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Totter s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Totter", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Totter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Totter s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Totter", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Totter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Totter s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Totter", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Totter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Totter s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Totter", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Totter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Totter s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Totter", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Totter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Totter s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Totter", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Totter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Totter s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Totter", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Totter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Totter s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Totter", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Totter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Totter s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Totter", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Totter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Totter s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod gnosis {
        use super::*;

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Gnosis", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Gnosis::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Gnosis s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Gnosis", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Gnosis::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Gnosis s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Gnosis", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Gnosis::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Gnosis s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Gnosis", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Gnosis::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Gnosis s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Gnosis", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Gnosis::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Gnosis s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Gnosis", 0.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Gnosis::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Gnosis s3 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Gnosis", 300.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Gnosis::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Gnosis s3 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Gnosis", 0.0, 20.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Gnosis::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Gnosis s3 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Gnosis", 500.0, 30.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Gnosis::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Gnosis s3 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Gnosis", 1000.0, 50.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Gnosis::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Gnosis s3 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod greyy_alter {
        use super::*;

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("GreyyAlter", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = GreyyAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "GreyyAlter s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("GreyyAlter", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = GreyyAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "GreyyAlter s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("GreyyAlter", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = GreyyAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "GreyyAlter s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("GreyyAlter", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = GreyyAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "GreyyAlter s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("GreyyAlter", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = GreyyAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "GreyyAlter s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("GreyyAlter", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = GreyyAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "GreyyAlter s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("GreyyAlter", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = GreyyAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "GreyyAlter s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("GreyyAlter", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = GreyyAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "GreyyAlter s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("GreyyAlter", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = GreyyAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "GreyyAlter s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("GreyyAlter", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = GreyyAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "GreyyAlter s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod kjera {
        use super::*;

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Kjera", 0.0, 0.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Kjera::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Kjera s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Kjera", 300.0, 0.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Kjera::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Kjera s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Kjera", 0.0, 20.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Kjera::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Kjera s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Kjera", 500.0, 30.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Kjera::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Kjera s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Kjera", 1000.0, 50.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Kjera::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Kjera s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Kjera", 0.0, 0.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Kjera::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Kjera s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Kjera", 300.0, 0.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Kjera::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Kjera s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Kjera", 0.0, 20.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Kjera::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Kjera s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Kjera", 500.0, 30.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Kjera::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Kjera s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Kjera", 1000.0, 50.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Kjera::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Kjera s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod lemuen {
        use super::*;

        #[test]
        fn test_s3_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Lemuen", 0.0, 0.0, 2, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 2);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Lemuen::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Lemuen s3 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Lemuen", 300.0, 0.0, 2, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 2);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Lemuen::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Lemuen s3 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Lemuen", 0.0, 20.0, 2, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 2);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Lemuen::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Lemuen s3 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Lemuen", 500.0, 30.0, 2, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 2);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Lemuen::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Lemuen s3 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Lemuen", 1000.0, 50.0, 2, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 2);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Lemuen::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Lemuen s3 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Lemuen", 0.0, 0.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Lemuen::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Lemuen s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Lemuen", 300.0, 0.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Lemuen::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Lemuen s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Lemuen", 0.0, 20.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Lemuen::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Lemuen s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Lemuen", 500.0, 30.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Lemuen::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Lemuen s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Lemuen", 1000.0, 50.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Lemuen::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Lemuen s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Lemuen", 0.0, 0.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Lemuen::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Lemuen s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Lemuen", 300.0, 0.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Lemuen::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Lemuen s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Lemuen", 0.0, 20.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Lemuen::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Lemuen s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Lemuen", 500.0, 30.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Lemuen::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Lemuen s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Lemuen", 1000.0, 50.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Lemuen::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Lemuen s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod meteor {
        use super::*;

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Meteor", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Meteor::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Meteor s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Meteor", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Meteor::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Meteor s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Meteor", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Meteor::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Meteor s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Meteor", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Meteor::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Meteor s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Meteor", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Meteor::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Meteor s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod skadi {
        use super::*;

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Skadi", 0.0, 0.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Skadi::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Skadi s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Skadi", 300.0, 0.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Skadi::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Skadi s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Skadi", 0.0, 20.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Skadi::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Skadi s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Skadi", 500.0, 30.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Skadi::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Skadi s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Skadi", 1000.0, 50.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Skadi::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Skadi s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Skadi", 0.0, 0.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Skadi::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Skadi s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Skadi", 300.0, 0.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Skadi::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Skadi s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Skadi", 0.0, 20.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Skadi::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Skadi s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Skadi", 500.0, 30.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Skadi::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Skadi s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Skadi", 1000.0, 50.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Skadi::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Skadi s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Skadi", 0.0, 0.0, 2, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 2);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Skadi::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Skadi s3 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Skadi", 300.0, 0.0, 2, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 2);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Skadi::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Skadi s3 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Skadi", 0.0, 20.0, 2, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 2);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Skadi::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Skadi s3 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Skadi", 500.0, 30.0, 2, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 2);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Skadi::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Skadi s3 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Skadi", 1000.0, 50.0, 2, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 2);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Skadi::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Skadi s3 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod rangers {
        use super::*;

        #[test]
        fn test_base_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Rangers", 0.0, 0.0, -1, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(-1, -1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Rangers::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Rangers base def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_base_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Rangers", 300.0, 0.0, -1, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(-1, -1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Rangers::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Rangers base def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_base_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Rangers", 0.0, 20.0, -1, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(-1, -1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Rangers::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Rangers base def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_base_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Rangers", 500.0, 30.0, -1, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(-1, -1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Rangers::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Rangers base def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_base_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Rangers", 1000.0, 50.0, -1, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(-1, -1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Rangers::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Rangers base def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod specter_alter {
        use super::*;

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("SpecterAlter", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = SpecterAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "SpecterAlter s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("SpecterAlter", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = SpecterAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "SpecterAlter s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("SpecterAlter", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = SpecterAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "SpecterAlter s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("SpecterAlter", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = SpecterAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "SpecterAlter s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("SpecterAlter", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = SpecterAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "SpecterAlter s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("SpecterAlter", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = SpecterAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "SpecterAlter s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("SpecterAlter", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = SpecterAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "SpecterAlter s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("SpecterAlter", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = SpecterAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "SpecterAlter s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("SpecterAlter", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = SpecterAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "SpecterAlter s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("SpecterAlter", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = SpecterAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "SpecterAlter s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("SpecterAlter", 0.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = SpecterAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "SpecterAlter s3 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("SpecterAlter", 300.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = SpecterAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "SpecterAlter s3 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("SpecterAlter", 0.0, 20.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = SpecterAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "SpecterAlter s3 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("SpecterAlter", 500.0, 30.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = SpecterAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "SpecterAlter s3 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("SpecterAlter", 1000.0, 50.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = SpecterAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "SpecterAlter s3 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod april {
        use super::*;

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("April", 0.0, 0.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = April::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "April s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("April", 300.0, 0.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = April::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "April s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("April", 0.0, 20.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = April::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "April s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("April", 500.0, 30.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = April::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "April s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("April", 1000.0, 50.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = April::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "April s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("April", 0.0, 0.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = April::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "April s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("April", 300.0, 0.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = April::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "April s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("April", 0.0, 20.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = April::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "April s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("April", 500.0, 30.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = April::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "April s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("April", 1000.0, 50.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = April::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "April s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod blue_poison {
        use super::*;

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("BluePoison", 0.0, 0.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = BluePoison::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "BluePoison s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("BluePoison", 300.0, 0.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = BluePoison::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "BluePoison s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("BluePoison", 0.0, 20.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = BluePoison::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "BluePoison s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("BluePoison", 500.0, 30.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = BluePoison::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "BluePoison s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("BluePoison", 1000.0, 50.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = BluePoison::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "BluePoison s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("BluePoison", 0.0, 0.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = BluePoison::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "BluePoison s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("BluePoison", 300.0, 0.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = BluePoison::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "BluePoison s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("BluePoison", 0.0, 20.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = BluePoison::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "BluePoison s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("BluePoison", 500.0, 30.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = BluePoison::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "BluePoison s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("BluePoison", 1000.0, 50.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = BluePoison::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "BluePoison s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod twelve_f {
        use super::*;

        #[test]
        fn test_base_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("twelveF", 0.0, 0.0, -1, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(-1, -1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = TwelveF::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "twelveF base def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_base_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("twelveF", 300.0, 0.0, -1, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(-1, -1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = TwelveF::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "twelveF base def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_base_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("twelveF", 0.0, 20.0, -1, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(-1, -1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = TwelveF::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "twelveF base def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_base_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("twelveF", 500.0, 30.0, -1, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(-1, -1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = TwelveF::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "twelveF base def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_base_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("twelveF", 1000.0, 50.0, -1, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(-1, -1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = TwelveF::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "twelveF base def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod humus {
        use super::*;

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Humus", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Humus::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Humus s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Humus", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Humus::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Humus s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Humus", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Humus::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Humus s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Humus", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Humus::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Humus s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Humus", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Humus::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Humus s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Humus", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Humus::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Humus s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Humus", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Humus::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Humus s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Humus", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Humus::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Humus s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Humus", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Humus::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Humus s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Humus", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Humus::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Humus s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod leizi_alter {
        use super::*;

        #[test]
        fn test_s3_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("LeiziAlter", 0.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = LeiziAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "LeiziAlter s3 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("LeiziAlter", 300.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = LeiziAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "LeiziAlter s3 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("LeiziAlter", 0.0, 20.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = LeiziAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "LeiziAlter s3 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("LeiziAlter", 500.0, 30.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = LeiziAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "LeiziAlter s3 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("LeiziAlter", 1000.0, 50.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = LeiziAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "LeiziAlter s3 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("LeiziAlter", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = LeiziAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "LeiziAlter s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("LeiziAlter", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = LeiziAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "LeiziAlter s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("LeiziAlter", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = LeiziAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "LeiziAlter s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("LeiziAlter", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = LeiziAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "LeiziAlter s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("LeiziAlter", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = LeiziAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "LeiziAlter s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("LeiziAlter", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = LeiziAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "LeiziAlter s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("LeiziAlter", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = LeiziAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "LeiziAlter s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("LeiziAlter", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = LeiziAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "LeiziAlter s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("LeiziAlter", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = LeiziAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "LeiziAlter s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("LeiziAlter", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = LeiziAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "LeiziAlter s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod catapult {
        use super::*;

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Catapult", 0.0, 0.0, 0, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, -1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Catapult::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Catapult s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Catapult", 300.0, 0.0, 0, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, -1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Catapult::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Catapult s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Catapult", 0.0, 20.0, 0, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, -1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Catapult::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Catapult s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Catapult", 500.0, 30.0, 0, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, -1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Catapult::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Catapult s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Catapult", 1000.0, 50.0, 0, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, -1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Catapult::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Catapult s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod schwarz {
        use super::*;

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Schwarz", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Schwarz::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Schwarz s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Schwarz", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Schwarz::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Schwarz s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Schwarz", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Schwarz::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Schwarz s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Schwarz", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Schwarz::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Schwarz s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Schwarz", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Schwarz::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Schwarz s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Schwarz", 0.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Schwarz::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Schwarz s3 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Schwarz", 300.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Schwarz::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Schwarz s3 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Schwarz", 0.0, 20.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Schwarz::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Schwarz s3 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Schwarz", 500.0, 30.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Schwarz::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Schwarz s3 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Schwarz", 1000.0, 50.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Schwarz::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Schwarz s3 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Schwarz", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Schwarz::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Schwarz s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Schwarz", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Schwarz::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Schwarz s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Schwarz", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Schwarz::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Schwarz s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Schwarz", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Schwarz::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Schwarz s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Schwarz", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Schwarz::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Schwarz s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod muelsyse {
        use super::*;

        #[test]
        fn test_s3_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Muelsyse", 0.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Muelsyse::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Muelsyse s3 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Muelsyse", 300.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Muelsyse::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Muelsyse s3 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Muelsyse", 0.0, 20.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Muelsyse::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Muelsyse s3 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Muelsyse", 500.0, 30.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Muelsyse::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Muelsyse s3 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Muelsyse", 1000.0, 50.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Muelsyse::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Muelsyse s3 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Muelsyse", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Muelsyse::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Muelsyse s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Muelsyse", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Muelsyse::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Muelsyse s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Muelsyse", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Muelsyse::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Muelsyse s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Muelsyse", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Muelsyse::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Muelsyse s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Muelsyse", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Muelsyse::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Muelsyse s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Muelsyse", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Muelsyse::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Muelsyse s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Muelsyse", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Muelsyse::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Muelsyse s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Muelsyse", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Muelsyse::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Muelsyse s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Muelsyse", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Muelsyse::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Muelsyse s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Muelsyse", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Muelsyse::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Muelsyse s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod vermeil {
        use super::*;

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Vermeil", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Vermeil::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Vermeil s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Vermeil", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Vermeil::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Vermeil s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Vermeil", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Vermeil::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Vermeil s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Vermeil", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Vermeil::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Vermeil s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Vermeil", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Vermeil::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Vermeil s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Vermeil", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Vermeil::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Vermeil s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Vermeil", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Vermeil::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Vermeil s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Vermeil", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Vermeil::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Vermeil s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Vermeil", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Vermeil::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Vermeil s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Vermeil", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Vermeil::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Vermeil s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod lunacub {
        use super::*;

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Lunacub", 0.0, 0.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Lunacub::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Lunacub s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Lunacub", 300.0, 0.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Lunacub::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Lunacub s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Lunacub", 0.0, 20.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Lunacub::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Lunacub s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Lunacub", 500.0, 30.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Lunacub::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Lunacub s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Lunacub", 1000.0, 50.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Lunacub::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Lunacub s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Lunacub", 0.0, 0.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Lunacub::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Lunacub s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Lunacub", 300.0, 0.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Lunacub::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Lunacub s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Lunacub", 0.0, 20.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Lunacub::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Lunacub s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Lunacub", 500.0, 30.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Lunacub::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Lunacub s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Lunacub", 1000.0, 50.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Lunacub::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Lunacub s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod manticore {
        use super::*;

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Manticore", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Manticore::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Manticore s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Manticore", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Manticore::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Manticore s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Manticore", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Manticore::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Manticore s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Manticore", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Manticore::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Manticore s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Manticore", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Manticore::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Manticore s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Manticore", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Manticore::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Manticore s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Manticore", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Manticore::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Manticore s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Manticore", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Manticore::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Manticore s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Manticore", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Manticore::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Manticore s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Manticore", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Manticore::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Manticore s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod crownslayer {
        use super::*;

        #[test]
        fn test_s3_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Crownslayer", 0.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Crownslayer::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Crownslayer s3 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Crownslayer", 300.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Crownslayer::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Crownslayer s3 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Crownslayer", 0.0, 20.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Crownslayer::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Crownslayer s3 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Crownslayer", 500.0, 30.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Crownslayer::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Crownslayer s3 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Crownslayer", 1000.0, 50.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Crownslayer::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Crownslayer s3 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Crownslayer", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Crownslayer::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Crownslayer s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Crownslayer", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Crownslayer::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Crownslayer s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Crownslayer", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Crownslayer::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Crownslayer s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Crownslayer", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Crownslayer::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Crownslayer s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Crownslayer", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Crownslayer::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Crownslayer s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod logos {
        use super::*;

        #[test]
        fn test_s3_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Logos", 0.0, 0.0, 2, 3) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 3);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Logos::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Logos s3 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Logos", 300.0, 0.0, 2, 3) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 3);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Logos::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Logos s3 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Logos", 0.0, 20.0, 2, 3) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 3);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Logos::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Logos s3 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Logos", 500.0, 30.0, 2, 3) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 3);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Logos::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Logos s3 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Logos", 1000.0, 50.0, 2, 3) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 3);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Logos::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Logos s3 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Logos", 0.0, 0.0, 1, 3) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 3);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Logos::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Logos s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Logos", 300.0, 0.0, 1, 3) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 3);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Logos::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Logos s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Logos", 0.0, 20.0, 1, 3) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 3);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Logos::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Logos s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Logos", 500.0, 30.0, 1, 3) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 3);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Logos::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Logos s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Logos", 1000.0, 50.0, 1, 3) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 3);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Logos::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Logos s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Logos", 0.0, 0.0, 0, 3) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 3);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Logos::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Logos s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Logos", 300.0, 0.0, 0, 3) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 3);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Logos::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Logos s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Logos", 0.0, 20.0, 0, 3) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 3);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Logos::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Logos s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Logos", 500.0, 30.0, 0, 3) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 3);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Logos::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Logos s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Logos", 1000.0, 50.0, 0, 3) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 3);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Logos::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Logos s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod indra {
        use super::*;

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Indra", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Indra::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Indra s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Indra", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Indra::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Indra s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Indra", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Indra::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Indra s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Indra", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Indra::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Indra s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Indra", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Indra::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Indra s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Indra", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Indra::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Indra s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Indra", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Indra::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Indra s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Indra", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Indra::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Indra s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Indra", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Indra::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Indra s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Indra", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Indra::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Indra s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod wildmane {
        use super::*;

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Wildmane", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Wildmane::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Wildmane s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Wildmane", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Wildmane::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Wildmane s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Wildmane", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Wildmane::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Wildmane s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Wildmane", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Wildmane::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Wildmane s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Wildmane", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Wildmane::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Wildmane s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Wildmane", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Wildmane::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Wildmane s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Wildmane", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Wildmane::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Wildmane s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Wildmane", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Wildmane::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Wildmane s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Wildmane", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Wildmane::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Wildmane s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Wildmane", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Wildmane::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Wildmane s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod dorothy {
        use super::*;

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Dorothy", 0.0, 0.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Dorothy::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Dorothy s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Dorothy", 300.0, 0.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Dorothy::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Dorothy s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Dorothy", 0.0, 20.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Dorothy::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Dorothy s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Dorothy", 500.0, 30.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Dorothy::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Dorothy s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Dorothy", 1000.0, 50.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Dorothy::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Dorothy s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Dorothy", 0.0, 0.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Dorothy::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Dorothy s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Dorothy", 300.0, 0.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Dorothy::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Dorothy s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Dorothy", 0.0, 20.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Dorothy::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Dorothy s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Dorothy", 500.0, 30.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Dorothy::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Dorothy s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Dorothy", 1000.0, 50.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Dorothy::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Dorothy s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Dorothy", 0.0, 0.0, 2, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 2);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Dorothy::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Dorothy s3 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Dorothy", 300.0, 0.0, 2, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 2);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Dorothy::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Dorothy s3 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Dorothy", 0.0, 20.0, 2, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 2);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Dorothy::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Dorothy s3 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Dorothy", 500.0, 30.0, 2, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 2);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Dorothy::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Dorothy s3 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Dorothy", 1000.0, 50.0, 2, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 2);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Dorothy::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Dorothy s3 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod figurino {
        use super::*;

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Figurino", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Figurino::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Figurino s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Figurino", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Figurino::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Figurino s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Figurino", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Figurino::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Figurino s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Figurino", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Figurino::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Figurino s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Figurino", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Figurino::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Figurino s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Figurino", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Figurino::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Figurino s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Figurino", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Figurino::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Figurino s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Figurino", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Figurino::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Figurino s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Figurino", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Figurino::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Figurino s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Figurino", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Figurino::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Figurino s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod nian {
        use super::*;

        #[test]
        fn test_s3_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Nian", 0.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Nian::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Nian s3 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Nian", 300.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Nian::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Nian s3 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Nian", 0.0, 20.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Nian::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Nian s3 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Nian", 500.0, 30.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Nian::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Nian s3 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Nian", 1000.0, 50.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Nian::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Nian s3 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Nian", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Nian::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Nian s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Nian", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Nian::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Nian s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Nian", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Nian::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Nian s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Nian", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Nian::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Nian s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Nian", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Nian::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Nian s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Nian", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Nian::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Nian s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Nian", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Nian::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Nian s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Nian", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Nian::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Nian s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Nian", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Nian::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Nian s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Nian", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Nian::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Nian s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod gladiia {
        use super::*;

        #[test]
        fn test_s3_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Gladiia", 0.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Gladiia::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Gladiia s3 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Gladiia", 300.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Gladiia::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Gladiia s3 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Gladiia", 0.0, 20.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Gladiia::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Gladiia s3 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Gladiia", 500.0, 30.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Gladiia::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Gladiia s3 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Gladiia", 1000.0, 50.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Gladiia::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Gladiia s3 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Gladiia", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Gladiia::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Gladiia s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Gladiia", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Gladiia::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Gladiia s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Gladiia", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Gladiia::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Gladiia s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Gladiia", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Gladiia::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Gladiia s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Gladiia", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Gladiia::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Gladiia s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Gladiia", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Gladiia::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Gladiia s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Gladiia", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Gladiia::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Gladiia s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Gladiia", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Gladiia::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Gladiia s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Gladiia", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Gladiia::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Gladiia s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Gladiia", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Gladiia::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Gladiia s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod silver_ash {
        use super::*;

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("SilverAsh", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = SilverAsh::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "SilverAsh s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("SilverAsh", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = SilverAsh::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "SilverAsh s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("SilverAsh", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = SilverAsh::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "SilverAsh s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("SilverAsh", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = SilverAsh::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "SilverAsh s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("SilverAsh", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = SilverAsh::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "SilverAsh s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("SilverAsh", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = SilverAsh::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "SilverAsh s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("SilverAsh", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = SilverAsh::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "SilverAsh s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("SilverAsh", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = SilverAsh::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "SilverAsh s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("SilverAsh", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = SilverAsh::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "SilverAsh s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("SilverAsh", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = SilverAsh::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "SilverAsh s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("SilverAsh", 0.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = SilverAsh::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "SilverAsh s3 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("SilverAsh", 300.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = SilverAsh::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "SilverAsh s3 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("SilverAsh", 0.0, 20.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = SilverAsh::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "SilverAsh s3 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("SilverAsh", 500.0, 30.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = SilverAsh::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "SilverAsh s3 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("SilverAsh", 1000.0, 50.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = SilverAsh::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "SilverAsh s3 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod frost {
        use super::*;

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Frost", 0.0, 0.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Frost::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Frost s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Frost", 300.0, 0.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Frost::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Frost s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Frost", 0.0, 20.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Frost::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Frost s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Frost", 500.0, 30.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Frost::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Frost s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Frost", 1000.0, 50.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Frost::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Frost s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Frost", 0.0, 0.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Frost::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Frost s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Frost", 300.0, 0.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Frost::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Frost s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Frost", 0.0, 20.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Frost::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Frost s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Frost", 500.0, 30.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Frost::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Frost s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Frost", 1000.0, 50.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Frost::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Frost s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod scavenger {
        use super::*;

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Scavenger", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Scavenger::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Scavenger s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Scavenger", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Scavenger::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Scavenger s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Scavenger", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Scavenger::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Scavenger s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Scavenger", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Scavenger::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Scavenger s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Scavenger", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Scavenger::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Scavenger s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Scavenger", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Scavenger::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Scavenger s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Scavenger", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Scavenger::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Scavenger s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Scavenger", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Scavenger::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Scavenger s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Scavenger", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Scavenger::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Scavenger s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Scavenger", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Scavenger::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Scavenger s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod blaze {
        use super::*;

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Blaze", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Blaze::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Blaze s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Blaze", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Blaze::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Blaze s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Blaze", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Blaze::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Blaze s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Blaze", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Blaze::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Blaze s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Blaze", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Blaze::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Blaze s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Blaze", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Blaze::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Blaze s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Blaze", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Blaze::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Blaze s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Blaze", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Blaze::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Blaze s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Blaze", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Blaze::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Blaze s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Blaze", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Blaze::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Blaze s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod w {
        use super::*;

        #[test]
        fn test_s3_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("W", 0.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = W::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "W s3 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("W", 300.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = W::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "W s3 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("W", 0.0, 20.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = W::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "W s3 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("W", 500.0, 30.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = W::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "W s3 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("W", 1000.0, 50.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = W::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "W s3 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("W", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = W::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "W s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("W", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = W::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "W s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("W", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = W::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "W s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("W", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = W::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "W s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("W", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = W::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "W s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("W", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = W::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "W s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("W", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = W::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "W s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("W", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = W::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "W s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("W", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = W::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "W s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("W", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = W::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "W s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod swire_alt {
        use super::*;

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("SwireAlt", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = SwireAlt::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "SwireAlt s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("SwireAlt", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = SwireAlt::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "SwireAlt s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("SwireAlt", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = SwireAlt::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "SwireAlt s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("SwireAlt", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = SwireAlt::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "SwireAlt s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("SwireAlt", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = SwireAlt::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "SwireAlt s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("SwireAlt", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = SwireAlt::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "SwireAlt s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("SwireAlt", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = SwireAlt::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "SwireAlt s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("SwireAlt", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = SwireAlt::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "SwireAlt s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("SwireAlt", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = SwireAlt::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "SwireAlt s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("SwireAlt", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = SwireAlt::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "SwireAlt s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("SwireAlt", 0.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = SwireAlt::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "SwireAlt s3 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("SwireAlt", 300.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = SwireAlt::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "SwireAlt s3 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("SwireAlt", 0.0, 20.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = SwireAlt::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "SwireAlt s3 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("SwireAlt", 500.0, 30.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = SwireAlt::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "SwireAlt s3 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("SwireAlt", 1000.0, 50.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = SwireAlt::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "SwireAlt s3 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod goldenglow {
        use super::*;

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Goldenglow", 0.0, 0.0, 0, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, -1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Goldenglow::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Goldenglow s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Goldenglow", 300.0, 0.0, 0, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, -1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Goldenglow::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Goldenglow s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Goldenglow", 0.0, 20.0, 0, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, -1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Goldenglow::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Goldenglow s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Goldenglow", 500.0, 30.0, 0, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, -1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Goldenglow::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Goldenglow s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Goldenglow", 1000.0, 50.0, 0, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, -1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Goldenglow::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Goldenglow s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Goldenglow", 0.0, 0.0, 2, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, -1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Goldenglow::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Goldenglow s3 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Goldenglow", 300.0, 0.0, 2, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, -1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Goldenglow::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Goldenglow s3 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Goldenglow", 0.0, 20.0, 2, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, -1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Goldenglow::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Goldenglow s3 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Goldenglow", 500.0, 30.0, 2, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, -1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Goldenglow::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Goldenglow s3 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Goldenglow", 1000.0, 50.0, 2, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, -1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Goldenglow::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Goldenglow s3 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Goldenglow", 0.0, 0.0, 1, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, -1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Goldenglow::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Goldenglow s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Goldenglow", 300.0, 0.0, 1, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, -1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Goldenglow::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Goldenglow s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Goldenglow", 0.0, 20.0, 1, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, -1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Goldenglow::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Goldenglow s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Goldenglow", 500.0, 30.0, 1, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, -1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Goldenglow::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Goldenglow s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Goldenglow", 1000.0, 50.0, 1, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, -1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Goldenglow::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Goldenglow s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod angelina {
        use super::*;

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Angelina", 0.0, 0.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Angelina::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Angelina s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Angelina", 300.0, 0.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Angelina::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Angelina s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Angelina", 0.0, 20.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Angelina::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Angelina s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Angelina", 500.0, 30.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Angelina::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Angelina s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Angelina", 1000.0, 50.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Angelina::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Angelina s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Angelina", 0.0, 0.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Angelina::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Angelina s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Angelina", 300.0, 0.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Angelina::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Angelina s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Angelina", 0.0, 20.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Angelina::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Angelina s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Angelina", 500.0, 30.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Angelina::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Angelina s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Angelina", 1000.0, 50.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Angelina::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Angelina s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Angelina", 0.0, 0.0, 2, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 2);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Angelina::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Angelina s3 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Angelina", 300.0, 0.0, 2, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 2);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Angelina::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Angelina s3 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Angelina", 0.0, 20.0, 2, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 2);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Angelina::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Angelina s3 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Angelina", 500.0, 30.0, 2, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 2);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Angelina::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Angelina s3 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Angelina", 1000.0, 50.0, 2, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 2);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Angelina::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Angelina s3 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod vulpisfoglia {
        use super::*;

        #[test]
        fn test_s3_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Vulpisfoglia", 0.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Vulpisfoglia::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Vulpisfoglia s3 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Vulpisfoglia", 300.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Vulpisfoglia::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Vulpisfoglia s3 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Vulpisfoglia", 0.0, 20.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Vulpisfoglia::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Vulpisfoglia s3 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Vulpisfoglia", 500.0, 30.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Vulpisfoglia::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Vulpisfoglia s3 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Vulpisfoglia", 1000.0, 50.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Vulpisfoglia::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Vulpisfoglia s3 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Vulpisfoglia", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Vulpisfoglia::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Vulpisfoglia s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Vulpisfoglia", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Vulpisfoglia::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Vulpisfoglia s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Vulpisfoglia", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Vulpisfoglia::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Vulpisfoglia s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Vulpisfoglia", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Vulpisfoglia::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Vulpisfoglia s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Vulpisfoglia", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Vulpisfoglia::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Vulpisfoglia s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod durin {
        use super::*;

        #[test]
        fn test_base_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Durin", 0.0, 0.0, -1, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(-1, -1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Durin::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Durin base def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_base_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Durin", 300.0, 0.0, -1, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(-1, -1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Durin::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Durin base def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_base_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Durin", 0.0, 20.0, -1, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(-1, -1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Durin::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Durin base def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_base_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Durin", 500.0, 30.0, -1, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(-1, -1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Durin::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Durin base def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_base_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Durin", 1000.0, 50.0, -1, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(-1, -1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Durin::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Durin base def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod lappland_alter {
        use super::*;

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("LapplandAlter", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = LapplandAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "LapplandAlter s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("LapplandAlter", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = LapplandAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "LapplandAlter s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("LapplandAlter", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = LapplandAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "LapplandAlter s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("LapplandAlter", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = LapplandAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "LapplandAlter s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("LapplandAlter", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = LapplandAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "LapplandAlter s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("LapplandAlter", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = LapplandAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "LapplandAlter s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("LapplandAlter", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = LapplandAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "LapplandAlter s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("LapplandAlter", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = LapplandAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "LapplandAlter s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("LapplandAlter", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = LapplandAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "LapplandAlter s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("LapplandAlter", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = LapplandAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "LapplandAlter s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("LapplandAlter", 0.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = LapplandAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "LapplandAlter s3 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("LapplandAlter", 300.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = LapplandAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "LapplandAlter s3 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("LapplandAlter", 0.0, 20.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = LapplandAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "LapplandAlter s3 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("LapplandAlter", 500.0, 30.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = LapplandAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "LapplandAlter s3 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("LapplandAlter", 1000.0, 50.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = LapplandAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "LapplandAlter s3 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod walter {
        use super::*;

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Walter", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Walter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Walter s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Walter", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Walter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Walter s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Walter", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Walter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Walter s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Walter", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Walter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Walter s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Walter", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Walter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Walter s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Walter", 0.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Walter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Walter s3 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Walter", 300.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Walter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Walter s3 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Walter", 0.0, 20.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Walter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Walter s3 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Walter", 500.0, 30.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Walter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Walter s3 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Walter", 1000.0, 50.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Walter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Walter s3 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Walter", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Walter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Walter s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Walter", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Walter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Walter s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Walter", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Walter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Walter s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Walter", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Walter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Walter s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Walter", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Walter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Walter s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod blemishine {
        use super::*;

        #[test]
        fn test_s3_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Blemishine", 0.0, 0.0, 2, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 2);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Blemishine::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Blemishine s3 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Blemishine", 300.0, 0.0, 2, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 2);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Blemishine::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Blemishine s3 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Blemishine", 0.0, 20.0, 2, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 2);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Blemishine::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Blemishine s3 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Blemishine", 500.0, 30.0, 2, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 2);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Blemishine::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Blemishine s3 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Blemishine", 1000.0, 50.0, 2, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 2);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Blemishine::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Blemishine s3 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Blemishine", 0.0, 0.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Blemishine::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Blemishine s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Blemishine", 300.0, 0.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Blemishine::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Blemishine s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Blemishine", 0.0, 20.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Blemishine::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Blemishine s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Blemishine", 500.0, 30.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Blemishine::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Blemishine s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Blemishine", 1000.0, 50.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Blemishine::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Blemishine s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Blemishine", 0.0, 0.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Blemishine::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Blemishine s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Blemishine", 300.0, 0.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Blemishine::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Blemishine s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Blemishine", 0.0, 20.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Blemishine::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Blemishine s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Blemishine", 500.0, 30.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Blemishine::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Blemishine s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Blemishine", 1000.0, 50.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Blemishine::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Blemishine s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod necrass {
        use super::*;

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Necrass", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Necrass::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Necrass s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Necrass", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Necrass::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Necrass s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Necrass", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Necrass::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Necrass s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Necrass", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Necrass::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Necrass s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Necrass", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Necrass::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Necrass s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Necrass", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Necrass::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Necrass s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Necrass", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Necrass::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Necrass s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Necrass", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Necrass::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Necrass s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Necrass", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Necrass::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Necrass s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Necrass", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Necrass::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Necrass s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Necrass", 0.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Necrass::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Necrass s3 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Necrass", 300.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Necrass::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Necrass s3 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Necrass", 0.0, 20.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Necrass::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Necrass s3 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Necrass", 500.0, 30.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Necrass::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Necrass s3 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Necrass", 1000.0, 50.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Necrass::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Necrass s3 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod odda {
        use super::*;

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Odda", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Odda::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Odda s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Odda", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Odda::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Odda s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Odda", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Odda::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Odda s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Odda", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Odda::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Odda s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Odda", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Odda::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Odda s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Odda", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Odda::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Odda s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Odda", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Odda::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Odda s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Odda", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Odda::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Odda s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Odda", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Odda::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Odda s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Odda", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Odda::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Odda s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod dagda {
        use super::*;

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Dagda", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Dagda::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Dagda s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Dagda", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Dagda::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Dagda s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Dagda", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Dagda::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Dagda s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Dagda", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Dagda::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Dagda s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Dagda", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Dagda::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Dagda s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Dagda", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Dagda::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Dagda s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Dagda", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Dagda::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Dagda s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Dagda", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Dagda::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Dagda s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Dagda", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Dagda::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Dagda s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Dagda", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Dagda::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Dagda s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod caper {
        use super::*;

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Caper", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Caper::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Caper s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Caper", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Caper::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Caper s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Caper", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Caper::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Caper s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Caper", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Caper::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Caper s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Caper", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Caper::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Caper s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Caper", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Caper::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Caper s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Caper", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Caper::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Caper s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Caper", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Caper::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Caper s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Caper", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Caper::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Caper s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Caper", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Caper::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Caper s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod virtuosa {
        use super::*;

        #[test]
        fn test_s3_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Virtuosa", 0.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Virtuosa::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Virtuosa s3 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Virtuosa", 300.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Virtuosa::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Virtuosa s3 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Virtuosa", 0.0, 20.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Virtuosa::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Virtuosa s3 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Virtuosa", 500.0, 30.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Virtuosa::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Virtuosa s3 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Virtuosa", 1000.0, 50.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Virtuosa::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Virtuosa s3 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Virtuosa", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Virtuosa::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Virtuosa s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Virtuosa", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Virtuosa::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Virtuosa s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Virtuosa", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Virtuosa::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Virtuosa s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Virtuosa", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Virtuosa::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Virtuosa s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Virtuosa", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Virtuosa::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Virtuosa s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Virtuosa", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Virtuosa::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Virtuosa s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Virtuosa", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Virtuosa::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Virtuosa s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Virtuosa", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Virtuosa::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Virtuosa s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Virtuosa", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Virtuosa::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Virtuosa s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Virtuosa", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Virtuosa::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Virtuosa s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod projekt_red {
        use super::*;

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("ProjektRed", 0.0, 0.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = ProjektRed::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "ProjektRed s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("ProjektRed", 300.0, 0.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = ProjektRed::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "ProjektRed s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("ProjektRed", 0.0, 20.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = ProjektRed::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "ProjektRed s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("ProjektRed", 500.0, 30.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = ProjektRed::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "ProjektRed s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("ProjektRed", 1000.0, 50.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = ProjektRed::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "ProjektRed s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod tecno {
        use super::*;

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Tecno", 0.0, 0.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Tecno::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Tecno s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Tecno", 300.0, 0.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Tecno::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Tecno s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Tecno", 0.0, 20.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Tecno::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Tecno s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Tecno", 500.0, 30.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Tecno::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Tecno s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Tecno", 1000.0, 50.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Tecno::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Tecno s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Tecno", 0.0, 0.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Tecno::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Tecno s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Tecno", 300.0, 0.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Tecno::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Tecno s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Tecno", 0.0, 20.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Tecno::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Tecno s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Tecno", 500.0, 30.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Tecno::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Tecno s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Tecno", 1000.0, 50.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Tecno::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Tecno s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod popukar {
        use super::*;

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Popukar", 0.0, 0.0, 0, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, -1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Popukar::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Popukar s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Popukar", 300.0, 0.0, 0, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, -1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Popukar::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Popukar s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Popukar", 0.0, 20.0, 0, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, -1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Popukar::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Popukar s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Popukar", 500.0, 30.0, 0, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, -1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Popukar::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Popukar s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Popukar", 1000.0, 50.0, 0, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, -1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Popukar::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Popukar s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod estelle {
        use super::*;

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Estelle", 0.0, 0.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Estelle::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Estelle s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Estelle", 300.0, 0.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Estelle::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Estelle s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Estelle", 0.0, 20.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Estelle::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Estelle s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Estelle", 500.0, 30.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Estelle::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Estelle s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Estelle", 1000.0, 50.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Estelle::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Estelle s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Estelle", 0.0, 0.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Estelle::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Estelle s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Estelle", 300.0, 0.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Estelle::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Estelle s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Estelle", 0.0, 20.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Estelle::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Estelle s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Estelle", 500.0, 30.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Estelle::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Estelle s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Estelle", 1000.0, 50.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Estelle::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Estelle s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod frostleaf {
        use super::*;

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Frostleaf", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Frostleaf::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Frostleaf s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Frostleaf", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Frostleaf::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Frostleaf s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Frostleaf", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Frostleaf::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Frostleaf s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Frostleaf", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Frostleaf::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Frostleaf s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Frostleaf", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Frostleaf::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Frostleaf s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Frostleaf", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Frostleaf::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Frostleaf s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Frostleaf", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Frostleaf::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Frostleaf s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Frostleaf", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Frostleaf::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Frostleaf s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Frostleaf", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Frostleaf::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Frostleaf s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Frostleaf", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Frostleaf::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Frostleaf s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod yutenji_nyamu {
        use super::*;

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("YutenjiNyamu", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = YutenjiNyamu::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "YutenjiNyamu s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("YutenjiNyamu", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = YutenjiNyamu::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "YutenjiNyamu s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("YutenjiNyamu", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = YutenjiNyamu::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "YutenjiNyamu s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("YutenjiNyamu", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = YutenjiNyamu::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "YutenjiNyamu s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("YutenjiNyamu", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = YutenjiNyamu::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "YutenjiNyamu s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("YutenjiNyamu", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = YutenjiNyamu::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "YutenjiNyamu s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("YutenjiNyamu", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = YutenjiNyamu::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "YutenjiNyamu s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("YutenjiNyamu", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = YutenjiNyamu::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "YutenjiNyamu s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("YutenjiNyamu", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = YutenjiNyamu::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "YutenjiNyamu s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("YutenjiNyamu", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = YutenjiNyamu::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "YutenjiNyamu s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod dusk {
        use super::*;

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Dusk", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Dusk::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Dusk s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Dusk", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Dusk::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Dusk s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Dusk", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Dusk::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Dusk s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Dusk", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Dusk::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Dusk s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Dusk", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Dusk::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Dusk s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Dusk", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Dusk::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Dusk s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Dusk", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Dusk::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Dusk s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Dusk", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Dusk::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Dusk s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Dusk", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Dusk::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Dusk s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Dusk", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Dusk::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Dusk s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Dusk", 0.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Dusk::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Dusk s3 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Dusk", 300.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Dusk::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Dusk s3 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Dusk", 0.0, 20.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Dusk::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Dusk s3 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Dusk", 500.0, 30.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Dusk::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Dusk s3 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Dusk", 1000.0, 50.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Dusk::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Dusk s3 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod aosta {
        use super::*;

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Aosta", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Aosta::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Aosta s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Aosta", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Aosta::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Aosta s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Aosta", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Aosta::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Aosta s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Aosta", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Aosta::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Aosta s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Aosta", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Aosta::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Aosta s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Aosta", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Aosta::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Aosta s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Aosta", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Aosta::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Aosta s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Aosta", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Aosta::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Aosta s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Aosta", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Aosta::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Aosta s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Aosta", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Aosta::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Aosta s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod lucilla {
        use super::*;

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Lucilla", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Lucilla::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Lucilla s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Lucilla", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Lucilla::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Lucilla s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Lucilla", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Lucilla::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Lucilla s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Lucilla", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Lucilla::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Lucilla s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Lucilla", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Lucilla::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Lucilla s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Lucilla", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Lucilla::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Lucilla s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Lucilla", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Lucilla::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Lucilla s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Lucilla", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Lucilla::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Lucilla s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Lucilla", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Lucilla::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Lucilla s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Lucilla", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Lucilla::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Lucilla s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod andreana {
        use super::*;

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Andreana", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Andreana::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Andreana s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Andreana", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Andreana::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Andreana s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Andreana", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Andreana::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Andreana s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Andreana", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Andreana::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Andreana s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Andreana", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Andreana::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Andreana s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Andreana", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Andreana::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Andreana s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Andreana", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Andreana::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Andreana s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Andreana", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Andreana::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Andreana s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Andreana", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Andreana::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Andreana s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Andreana", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Andreana::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Andreana s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod doc {
        use super::*;

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Doc", 0.0, 0.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Doc::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Doc s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Doc", 300.0, 0.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Doc::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Doc s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Doc", 0.0, 20.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Doc::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Doc s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Doc", 500.0, 30.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Doc::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Doc s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Doc", 1000.0, 50.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Doc::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Doc s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod executor_alter {
        use super::*;

        #[test]
        fn test_s3_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("ExecutorAlter", 0.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = ExecutorAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "ExecutorAlter s3 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("ExecutorAlter", 300.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = ExecutorAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "ExecutorAlter s3 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("ExecutorAlter", 0.0, 20.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = ExecutorAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "ExecutorAlter s3 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("ExecutorAlter", 500.0, 30.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = ExecutorAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "ExecutorAlter s3 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("ExecutorAlter", 1000.0, 50.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = ExecutorAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "ExecutorAlter s3 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("ExecutorAlter", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = ExecutorAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "ExecutorAlter s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("ExecutorAlter", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = ExecutorAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "ExecutorAlter s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("ExecutorAlter", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = ExecutorAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "ExecutorAlter s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("ExecutorAlter", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = ExecutorAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "ExecutorAlter s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("ExecutorAlter", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = ExecutorAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "ExecutorAlter s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("ExecutorAlter", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = ExecutorAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "ExecutorAlter s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("ExecutorAlter", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = ExecutorAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "ExecutorAlter s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("ExecutorAlter", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = ExecutorAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "ExecutorAlter s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("ExecutorAlter", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = ExecutorAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "ExecutorAlter s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("ExecutorAlter", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = ExecutorAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "ExecutorAlter s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod exusiai_alter {
        use super::*;

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("ExusiaiAlter", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = ExusiaiAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "ExusiaiAlter s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("ExusiaiAlter", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = ExusiaiAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "ExusiaiAlter s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("ExusiaiAlter", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = ExusiaiAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "ExusiaiAlter s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("ExusiaiAlter", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = ExusiaiAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "ExusiaiAlter s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("ExusiaiAlter", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = ExusiaiAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "ExusiaiAlter s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("ExusiaiAlter", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = ExusiaiAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "ExusiaiAlter s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("ExusiaiAlter", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = ExusiaiAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "ExusiaiAlter s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("ExusiaiAlter", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = ExusiaiAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "ExusiaiAlter s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("ExusiaiAlter", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = ExusiaiAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "ExusiaiAlter s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("ExusiaiAlter", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = ExusiaiAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "ExusiaiAlter s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("ExusiaiAlter", 0.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = ExusiaiAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "ExusiaiAlter s3 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("ExusiaiAlter", 300.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = ExusiaiAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "ExusiaiAlter s3 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("ExusiaiAlter", 0.0, 20.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = ExusiaiAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "ExusiaiAlter s3 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("ExusiaiAlter", 500.0, 30.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = ExusiaiAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "ExusiaiAlter s3 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("ExusiaiAlter", 1000.0, 50.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = ExusiaiAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "ExusiaiAlter s3 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod weedy {
        use super::*;

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Weedy", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Weedy::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Weedy s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Weedy", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Weedy::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Weedy s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Weedy", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Weedy::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Weedy s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Weedy", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Weedy::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Weedy s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Weedy", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Weedy::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Weedy s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Weedy", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Weedy::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Weedy s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Weedy", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Weedy::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Weedy s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Weedy", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Weedy::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Weedy s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Weedy", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Weedy::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Weedy s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Weedy", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Weedy::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Weedy s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod fiammetta {
        use super::*;

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Fiammetta", 0.0, 0.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Fiammetta::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Fiammetta s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Fiammetta", 300.0, 0.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Fiammetta::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Fiammetta s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Fiammetta", 0.0, 20.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Fiammetta::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Fiammetta s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Fiammetta", 500.0, 30.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Fiammetta::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Fiammetta s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Fiammetta", 1000.0, 50.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Fiammetta::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Fiammetta s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Fiammetta", 0.0, 0.0, 2, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 2);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Fiammetta::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Fiammetta s3 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Fiammetta", 300.0, 0.0, 2, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 2);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Fiammetta::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Fiammetta s3 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Fiammetta", 0.0, 20.0, 2, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 2);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Fiammetta::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Fiammetta s3 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Fiammetta", 500.0, 30.0, 2, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 2);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Fiammetta::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Fiammetta s3 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Fiammetta", 1000.0, 50.0, 2, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 2);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Fiammetta::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Fiammetta s3 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod haze {
        use super::*;

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Haze", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Haze::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Haze s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Haze", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Haze::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Haze s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Haze", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Haze::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Haze s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Haze", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Haze::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Haze s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Haze", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Haze::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Haze s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Haze", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Haze::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Haze s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Haze", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Haze::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Haze s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Haze", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Haze::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Haze s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Haze", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Haze::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Haze s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Haze", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Haze::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Haze s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod mon_3tr {
        use super::*;

        #[test]
        fn test_s3_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Mon3tr", 0.0, 0.0, 2, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, -1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Mon3tr::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Mon3tr s3 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Mon3tr", 300.0, 0.0, 2, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, -1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Mon3tr::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Mon3tr s3 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Mon3tr", 0.0, 20.0, 2, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, -1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Mon3tr::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Mon3tr s3 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Mon3tr", 500.0, 30.0, 2, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, -1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Mon3tr::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Mon3tr s3 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Mon3tr", 1000.0, 50.0, 2, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, -1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Mon3tr::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Mon3tr s3 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod typhon {
        use super::*;

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Typhon", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Typhon::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Typhon s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Typhon", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Typhon::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Typhon s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Typhon", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Typhon::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Typhon s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Typhon", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Typhon::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Typhon s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Typhon", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Typhon::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Typhon s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Typhon", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Typhon::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Typhon s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Typhon", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Typhon::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Typhon s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Typhon", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Typhon::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Typhon s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Typhon", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Typhon::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Typhon s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Typhon", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Typhon::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Typhon s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Typhon", 0.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Typhon::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Typhon s3 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Typhon", 300.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Typhon::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Typhon s3 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Typhon", 0.0, 20.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Typhon::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Typhon s3 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Typhon", 500.0, 30.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Typhon::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Typhon s3 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Typhon", 1000.0, 50.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Typhon::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Typhon s3 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod mountain {
        use super::*;

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Mountain", 0.0, 0.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Mountain::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Mountain s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Mountain", 300.0, 0.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Mountain::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Mountain s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Mountain", 0.0, 20.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Mountain::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Mountain s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Mountain", 500.0, 30.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Mountain::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Mountain s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Mountain", 1000.0, 50.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Mountain::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Mountain s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Mountain", 0.0, 0.0, 2, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 2);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Mountain::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Mountain s3 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Mountain", 300.0, 0.0, 2, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 2);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Mountain::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Mountain s3 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Mountain", 0.0, 20.0, 2, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 2);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Mountain::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Mountain s3 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Mountain", 500.0, 30.0, 2, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 2);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Mountain::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Mountain s3 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Mountain", 1000.0, 50.0, 2, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 2);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Mountain::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Mountain s3 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Mountain", 0.0, 0.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Mountain::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Mountain s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Mountain", 300.0, 0.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Mountain::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Mountain s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Mountain", 0.0, 20.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Mountain::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Mountain s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Mountain", 500.0, 30.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Mountain::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Mountain s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Mountain", 1000.0, 50.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Mountain::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Mountain s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod reed_alter {
        use super::*;

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("ReedAlter", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = ReedAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "ReedAlter s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("ReedAlter", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = ReedAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "ReedAlter s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("ReedAlter", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = ReedAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "ReedAlter s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("ReedAlter", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = ReedAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "ReedAlter s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("ReedAlter", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = ReedAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "ReedAlter s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("ReedAlter", 0.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = ReedAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "ReedAlter s3 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("ReedAlter", 300.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = ReedAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "ReedAlter s3 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("ReedAlter", 0.0, 20.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = ReedAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "ReedAlter s3 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("ReedAlter", 500.0, 30.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = ReedAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "ReedAlter s3 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("ReedAlter", 1000.0, 50.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = ReedAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "ReedAlter s3 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("ReedAlter", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = ReedAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "ReedAlter s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("ReedAlter", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = ReedAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "ReedAlter s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("ReedAlter", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = ReedAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "ReedAlter s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("ReedAlter", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = ReedAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "ReedAlter s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("ReedAlter", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = ReedAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "ReedAlter s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod eunectes {
        use super::*;

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Eunectes", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Eunectes::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Eunectes s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Eunectes", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Eunectes::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Eunectes s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Eunectes", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Eunectes::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Eunectes s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Eunectes", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Eunectes::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Eunectes s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Eunectes", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Eunectes::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Eunectes s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Eunectes", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Eunectes::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Eunectes s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Eunectes", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Eunectes::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Eunectes s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Eunectes", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Eunectes::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Eunectes s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Eunectes", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Eunectes::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Eunectes s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Eunectes", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Eunectes::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Eunectes s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Eunectes", 0.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Eunectes::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Eunectes s3 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Eunectes", 300.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Eunectes::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Eunectes s3 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Eunectes", 0.0, 20.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Eunectes::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Eunectes s3 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Eunectes", 500.0, 30.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Eunectes::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Eunectes s3 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Eunectes", 1000.0, 50.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Eunectes::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Eunectes s3 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod fartooth {
        use super::*;

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Fartooth", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Fartooth::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Fartooth s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Fartooth", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Fartooth::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Fartooth s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Fartooth", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Fartooth::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Fartooth s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Fartooth", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Fartooth::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Fartooth s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Fartooth", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Fartooth::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Fartooth s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Fartooth", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Fartooth::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Fartooth s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Fartooth", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Fartooth::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Fartooth s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Fartooth", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Fartooth::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Fartooth s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Fartooth", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Fartooth::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Fartooth s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Fartooth", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Fartooth::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Fartooth s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Fartooth", 0.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Fartooth::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Fartooth s3 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Fartooth", 300.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Fartooth::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Fartooth s3 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Fartooth", 0.0, 20.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Fartooth::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Fartooth s3 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Fartooth", 500.0, 30.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Fartooth::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Fartooth s3 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Fartooth", 1000.0, 50.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Fartooth::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Fartooth s3 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod broca {
        use super::*;

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Broca", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Broca::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Broca s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Broca", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Broca::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Broca s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Broca", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Broca::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Broca s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Broca", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Broca::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Broca s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Broca", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Broca::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Broca s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Broca", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Broca::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Broca s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Broca", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Broca::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Broca s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Broca", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Broca::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Broca s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Broca", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Broca::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Broca s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Broca", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Broca::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Broca s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod castle_3 {
        use super::*;

        #[test]
        fn test_base_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Castle3", 0.0, 0.0, -1, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(-1, -1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Castle3::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Castle3 base def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_base_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Castle3", 300.0, 0.0, -1, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(-1, -1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Castle3::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Castle3 base def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_base_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Castle3", 0.0, 20.0, -1, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(-1, -1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Castle3::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Castle3 base def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_base_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Castle3", 500.0, 30.0, -1, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(-1, -1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Castle3::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Castle3 base def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_base_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Castle3", 1000.0, 50.0, -1, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(-1, -1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Castle3::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Castle3 base def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod magallan {
        use super::*;

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Magallan", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Magallan::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Magallan s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Magallan", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Magallan::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Magallan s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Magallan", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Magallan::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Magallan s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Magallan", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Magallan::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Magallan s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Magallan", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Magallan::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Magallan s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Magallan", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Magallan::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Magallan s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Magallan", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Magallan::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Magallan s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Magallan", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Magallan::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Magallan s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Magallan", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Magallan::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Magallan s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Magallan", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Magallan::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Magallan s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Magallan", 0.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Magallan::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Magallan s3 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Magallan", 300.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Magallan::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Magallan s3 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Magallan", 0.0, 20.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Magallan::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Magallan s3 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Magallan", 500.0, 30.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Magallan::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Magallan s3 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Magallan", 1000.0, 50.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Magallan::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Magallan s3 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod amiya_medic {
        use super::*;

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("AmiyaMedic", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = AmiyaMedic::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "AmiyaMedic s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("AmiyaMedic", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = AmiyaMedic::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "AmiyaMedic s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("AmiyaMedic", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = AmiyaMedic::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "AmiyaMedic s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("AmiyaMedic", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = AmiyaMedic::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "AmiyaMedic s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("AmiyaMedic", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = AmiyaMedic::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "AmiyaMedic s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("AmiyaMedic", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = AmiyaMedic::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "AmiyaMedic s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("AmiyaMedic", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = AmiyaMedic::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "AmiyaMedic s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("AmiyaMedic", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = AmiyaMedic::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "AmiyaMedic s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("AmiyaMedic", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = AmiyaMedic::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "AmiyaMedic s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("AmiyaMedic", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = AmiyaMedic::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "AmiyaMedic s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod sideroca {
        use super::*;

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Sideroca", 0.0, 0.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Sideroca::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Sideroca s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Sideroca", 300.0, 0.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Sideroca::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Sideroca s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Sideroca", 0.0, 20.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Sideroca::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Sideroca s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Sideroca", 500.0, 30.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Sideroca::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Sideroca s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Sideroca", 1000.0, 50.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Sideroca::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Sideroca s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Sideroca", 0.0, 0.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Sideroca::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Sideroca s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Sideroca", 300.0, 0.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Sideroca::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Sideroca s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Sideroca", 0.0, 20.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Sideroca::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Sideroca s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Sideroca", 500.0, 30.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Sideroca::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Sideroca s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Sideroca", 1000.0, 50.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Sideroca::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Sideroca s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod thorns_alter {
        use super::*;

        #[test]
        fn test_s3_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("ThornsAlter", 0.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = ThornsAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "ThornsAlter s3 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("ThornsAlter", 300.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = ThornsAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "ThornsAlter s3 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("ThornsAlter", 0.0, 20.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = ThornsAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "ThornsAlter s3 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("ThornsAlter", 500.0, 30.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = ThornsAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "ThornsAlter s3 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("ThornsAlter", 1000.0, 50.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = ThornsAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "ThornsAlter s3 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("ThornsAlter", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = ThornsAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "ThornsAlter s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("ThornsAlter", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = ThornsAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "ThornsAlter s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("ThornsAlter", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = ThornsAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "ThornsAlter s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("ThornsAlter", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = ThornsAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "ThornsAlter s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("ThornsAlter", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = ThornsAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "ThornsAlter s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod ulpianus {
        use super::*;

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ulpianus", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ulpianus::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ulpianus s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ulpianus", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ulpianus::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ulpianus s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ulpianus", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ulpianus::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ulpianus s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ulpianus", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ulpianus::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ulpianus s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ulpianus", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ulpianus::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ulpianus s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ulpianus", 0.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ulpianus::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ulpianus s3 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ulpianus", 300.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ulpianus::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ulpianus s3 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ulpianus", 0.0, 20.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ulpianus::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ulpianus s3 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ulpianus", 500.0, 30.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ulpianus::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ulpianus s3 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ulpianus", 1000.0, 50.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ulpianus::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ulpianus s3 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ulpianus", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ulpianus::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ulpianus s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ulpianus", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ulpianus::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ulpianus s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ulpianus", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ulpianus::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ulpianus s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ulpianus", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ulpianus::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ulpianus s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ulpianus", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ulpianus::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ulpianus s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod thorns {
        use super::*;

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Thorns", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Thorns::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Thorns s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Thorns", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Thorns::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Thorns s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Thorns", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Thorns::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Thorns s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Thorns", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Thorns::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Thorns s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Thorns", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Thorns::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Thorns s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Thorns", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Thorns::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Thorns s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Thorns", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Thorns::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Thorns s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Thorns", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Thorns::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Thorns s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Thorns", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Thorns::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Thorns s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Thorns", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Thorns::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Thorns s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Thorns", 0.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Thorns::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Thorns s3 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Thorns", 300.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Thorns::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Thorns s3 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Thorns", 0.0, 20.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Thorns::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Thorns s3 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Thorns", 500.0, 30.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Thorns::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Thorns s3 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Thorns", 1000.0, 50.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Thorns::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Thorns s3 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod laios {
        use super::*;

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Laios", 0.0, 0.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Laios::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Laios s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Laios", 300.0, 0.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Laios::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Laios s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Laios", 0.0, 20.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Laios::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Laios s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Laios", 500.0, 30.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Laios::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Laios s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Laios", 1000.0, 50.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Laios::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Laios s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Laios", 0.0, 0.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Laios::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Laios s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Laios", 300.0, 0.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Laios::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Laios s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Laios", 0.0, 20.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Laios::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Laios s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Laios", 500.0, 30.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Laios::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Laios s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Laios", 1000.0, 50.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Laios::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Laios s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod insider {
        use super::*;

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Insider", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Insider::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Insider s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Insider", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Insider::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Insider s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Insider", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Insider::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Insider s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Insider", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Insider::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Insider s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Insider", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Insider::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Insider s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Insider", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Insider::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Insider s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Insider", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Insider::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Insider s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Insider", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Insider::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Insider s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Insider", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Insider::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Insider s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Insider", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Insider::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Insider s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod beehunter {
        use super::*;

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Beehunter", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Beehunter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Beehunter s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Beehunter", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Beehunter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Beehunter s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Beehunter", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Beehunter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Beehunter s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Beehunter", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Beehunter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Beehunter s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Beehunter", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Beehunter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Beehunter s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Beehunter", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Beehunter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Beehunter s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Beehunter", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Beehunter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Beehunter s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Beehunter", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Beehunter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Beehunter s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Beehunter", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Beehunter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Beehunter s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Beehunter", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Beehunter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Beehunter s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod fuze {
        use super::*;

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Fuze", 0.0, 0.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Fuze::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Fuze s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Fuze", 300.0, 0.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Fuze::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Fuze s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Fuze", 0.0, 20.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Fuze::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Fuze s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Fuze", 500.0, 30.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Fuze::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Fuze s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Fuze", 1000.0, 50.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Fuze::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Fuze s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Fuze", 0.0, 0.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Fuze::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Fuze s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Fuze", 300.0, 0.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Fuze::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Fuze s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Fuze", 0.0, 20.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Fuze::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Fuze s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Fuze", 500.0, 30.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Fuze::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Fuze s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Fuze", 1000.0, 50.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Fuze::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Fuze s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod meteorite {
        use super::*;

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Meteorite", 0.0, 0.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Meteorite::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Meteorite s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Meteorite", 300.0, 0.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Meteorite::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Meteorite s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Meteorite", 0.0, 20.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Meteorite::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Meteorite s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Meteorite", 500.0, 30.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Meteorite::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Meteorite s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Meteorite", 1000.0, 50.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Meteorite::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Meteorite s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod specter {
        use super::*;

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Specter", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Specter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Specter s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Specter", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Specter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Specter s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Specter", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Specter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Specter s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Specter", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Specter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Specter s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Specter", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Specter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Specter s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Specter", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Specter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Specter s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Specter", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Specter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Specter s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Specter", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Specter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Specter s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Specter", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Specter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Specter s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Specter", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Specter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Specter s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod blaze_alter {
        use super::*;

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("BlazeAlter", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = BlazeAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "BlazeAlter s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("BlazeAlter", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = BlazeAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "BlazeAlter s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("BlazeAlter", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = BlazeAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "BlazeAlter s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("BlazeAlter", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = BlazeAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "BlazeAlter s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("BlazeAlter", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = BlazeAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "BlazeAlter s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("BlazeAlter", 0.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = BlazeAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "BlazeAlter s3 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("BlazeAlter", 300.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = BlazeAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "BlazeAlter s3 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("BlazeAlter", 0.0, 20.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = BlazeAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "BlazeAlter s3 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("BlazeAlter", 500.0, 30.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = BlazeAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "BlazeAlter s3 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("BlazeAlter", 1000.0, 50.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = BlazeAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "BlazeAlter s3 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("BlazeAlter", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = BlazeAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "BlazeAlter s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("BlazeAlter", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = BlazeAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "BlazeAlter s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("BlazeAlter", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = BlazeAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "BlazeAlter s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("BlazeAlter", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = BlazeAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "BlazeAlter s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("BlazeAlter", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = BlazeAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "BlazeAlter s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod skalter {
        use super::*;

        #[test]
        fn test_s3_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Skalter", 0.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Skalter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Skalter s3 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Skalter", 300.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Skalter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Skalter s3 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Skalter", 0.0, 20.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Skalter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Skalter s3 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Skalter", 500.0, 30.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Skalter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Skalter s3 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Skalter", 1000.0, 50.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Skalter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Skalter s3 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Skalter", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Skalter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Skalter s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Skalter", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Skalter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Skalter s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Skalter", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Skalter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Skalter s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Skalter", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Skalter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Skalter s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Skalter", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Skalter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Skalter s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod ifrit {
        use super::*;

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ifrit", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ifrit::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ifrit s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ifrit", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ifrit::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ifrit s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ifrit", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ifrit::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ifrit s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ifrit", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ifrit::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ifrit s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ifrit", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ifrit::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ifrit s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ifrit", 0.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ifrit::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ifrit s3 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ifrit", 300.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ifrit::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ifrit s3 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ifrit", 0.0, 20.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ifrit::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ifrit s3 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ifrit", 500.0, 30.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ifrit::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ifrit s3 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ifrit", 1000.0, 50.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ifrit::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ifrit s3 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ifrit", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ifrit::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ifrit s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ifrit", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ifrit::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ifrit s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ifrit", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ifrit::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ifrit s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ifrit", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ifrit::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ifrit s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ifrit", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ifrit::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ifrit s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod vetochki {
        use super::*;

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Vetochki", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Vetochki::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Vetochki s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Vetochki", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Vetochki::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Vetochki s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Vetochki", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Vetochki::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Vetochki s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Vetochki", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Vetochki::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Vetochki s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Vetochki", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Vetochki::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Vetochki s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Vetochki", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Vetochki::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Vetochki s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Vetochki", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Vetochki::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Vetochki s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Vetochki", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Vetochki::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Vetochki s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Vetochki", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Vetochki::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Vetochki s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Vetochki", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Vetochki::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Vetochki s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod nymph {
        use super::*;

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Nymph", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Nymph::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Nymph s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Nymph", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Nymph::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Nymph s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Nymph", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Nymph::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Nymph s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Nymph", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Nymph::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Nymph s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Nymph", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Nymph::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Nymph s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Nymph", 0.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Nymph::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Nymph s3 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Nymph", 300.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Nymph::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Nymph s3 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Nymph", 0.0, 20.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Nymph::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Nymph s3 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Nymph", 500.0, 30.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Nymph::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Nymph s3 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Nymph", 1000.0, 50.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Nymph::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Nymph s3 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Nymph", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Nymph::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Nymph s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Nymph", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Nymph::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Nymph s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Nymph", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Nymph::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Nymph s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Nymph", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Nymph::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Nymph s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Nymph", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Nymph::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Nymph s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod aurora {
        use super::*;

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Aurora", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Aurora::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Aurora s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Aurora", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Aurora::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Aurora s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Aurora", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Aurora::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Aurora s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Aurora", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Aurora::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Aurora s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Aurora", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Aurora::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Aurora s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Aurora", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Aurora::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Aurora s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Aurora", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Aurora::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Aurora s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Aurora", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Aurora::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Aurora s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Aurora", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Aurora::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Aurora s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Aurora", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Aurora::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Aurora s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod ela {
        use super::*;

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ela", 0.0, 0.0, 1, 3) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 3);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ela::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ela s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ela", 300.0, 0.0, 1, 3) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 3);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ela::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ela s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ela", 0.0, 20.0, 1, 3) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 3);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ela::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ela s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ela", 500.0, 30.0, 1, 3) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 3);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ela::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ela s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ela", 1000.0, 50.0, 1, 3) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 3);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ela::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ela s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ela", 0.0, 0.0, 2, 3) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 3);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ela::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ela s3 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ela", 300.0, 0.0, 2, 3) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 3);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ela::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ela s3 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ela", 0.0, 20.0, 2, 3) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 3);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ela::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ela s3 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ela", 500.0, 30.0, 2, 3) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 3);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ela::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ela s3 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ela", 1000.0, 50.0, 2, 3) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 3);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ela::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ela s3 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ela", 0.0, 0.0, 0, 3) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 3);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ela::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ela s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ela", 300.0, 0.0, 0, 3) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 3);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ela::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ela s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ela", 0.0, 20.0, 0, 3) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 3);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ela::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ela s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ela", 500.0, 30.0, 0, 3) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 3);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ela::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ela s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ela", 1000.0, 50.0, 0, 3) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 3);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ela::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ela s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod hoederer {
        use super::*;

        #[test]
        fn test_s3_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Hoederer", 0.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Hoederer::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Hoederer s3 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Hoederer", 300.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Hoederer::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Hoederer s3 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Hoederer", 0.0, 20.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Hoederer::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Hoederer s3 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Hoederer", 500.0, 30.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Hoederer::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Hoederer s3 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Hoederer", 1000.0, 50.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Hoederer::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Hoederer s3 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Hoederer", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Hoederer::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Hoederer s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Hoederer", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Hoederer::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Hoederer s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Hoederer", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Hoederer::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Hoederer s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Hoederer", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Hoederer::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Hoederer s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Hoederer", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Hoederer::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Hoederer s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Hoederer", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Hoederer::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Hoederer s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Hoederer", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Hoederer::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Hoederer s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Hoederer", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Hoederer::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Hoederer s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Hoederer", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Hoederer::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Hoederer s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Hoederer", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Hoederer::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Hoederer s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod vigil {
        use super::*;

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Vigil", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Vigil::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Vigil s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Vigil", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Vigil::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Vigil s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Vigil", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Vigil::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Vigil s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Vigil", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Vigil::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Vigil s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Vigil", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Vigil::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Vigil s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Vigil", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Vigil::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Vigil s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Vigil", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Vigil::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Vigil s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Vigil", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Vigil::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Vigil s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Vigil", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Vigil::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Vigil s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Vigil", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Vigil::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Vigil s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Vigil", 0.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Vigil::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Vigil s3 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Vigil", 300.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Vigil::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Vigil s3 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Vigil", 0.0, 20.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Vigil::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Vigil s3 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Vigil", 500.0, 30.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Vigil::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Vigil s3 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Vigil", 1000.0, 50.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Vigil::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Vigil s3 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod lava_3star {
        use super::*;

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Lava3star", 0.0, 0.0, 0, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, -1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Lava3star::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Lava3star s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Lava3star", 300.0, 0.0, 0, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, -1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Lava3star::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Lava3star s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Lava3star", 0.0, 20.0, 0, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, -1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Lava3star::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Lava3star s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Lava3star", 500.0, 30.0, 0, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, -1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Lava3star::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Lava3star s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Lava3star", 1000.0, 50.0, 0, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, -1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Lava3star::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Lava3star s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod raidian {
        use super::*;

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Raidian", 0.0, 0.0, 0, 3) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 3);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Raidian::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Raidian s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Raidian", 300.0, 0.0, 0, 3) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 3);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Raidian::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Raidian s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Raidian", 0.0, 20.0, 0, 3) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 3);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Raidian::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Raidian s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Raidian", 500.0, 30.0, 0, 3) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 3);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Raidian::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Raidian s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Raidian", 1000.0, 50.0, 0, 3) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 3);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Raidian::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Raidian s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Raidian", 0.0, 0.0, 1, 3) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 3);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Raidian::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Raidian s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Raidian", 300.0, 0.0, 1, 3) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 3);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Raidian::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Raidian s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Raidian", 0.0, 20.0, 1, 3) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 3);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Raidian::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Raidian s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Raidian", 500.0, 30.0, 1, 3) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 3);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Raidian::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Raidian s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Raidian", 1000.0, 50.0, 1, 3) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 3);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Raidian::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Raidian s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Raidian", 0.0, 0.0, 2, 3) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 3);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Raidian::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Raidian s3 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Raidian", 300.0, 0.0, 2, 3) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 3);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Raidian::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Raidian s3 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Raidian", 0.0, 20.0, 2, 3) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 3);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Raidian::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Raidian s3 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Raidian", 500.0, 30.0, 2, 3) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 3);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Raidian::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Raidian s3 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Raidian", 1000.0, 50.0, 2, 3) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 3);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Raidian::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Raidian s3 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod siege {
        use super::*;

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Siege", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Siege::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Siege s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Siege", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Siege::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Siege s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Siege", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Siege::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Siege s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Siege", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Siege::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Siege s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Siege", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Siege::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Siege s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Siege", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Siege::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Siege s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Siege", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Siege::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Siege s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Siege", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Siege::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Siege s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Siege", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Siege::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Siege s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Siege", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Siege::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Siege s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Siege", 0.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Siege::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Siege s3 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Siege", 300.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Siege::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Siege s3 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Siege", 0.0, 20.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Siege::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Siege s3 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Siege", 500.0, 30.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Siege::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Siege s3 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Siege", 1000.0, 50.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Siege::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Siege s3 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod mousse {
        use super::*;

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Mousse", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Mousse::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Mousse s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Mousse", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Mousse::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Mousse s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Mousse", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Mousse::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Mousse s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Mousse", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Mousse::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Mousse s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Mousse", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Mousse::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Mousse s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Mousse", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Mousse::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Mousse s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Mousse", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Mousse::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Mousse s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Mousse", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Mousse::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Mousse s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Mousse", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Mousse::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Mousse s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Mousse", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Mousse::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Mousse s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod asbestos {
        use super::*;

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Asbestos", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Asbestos::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Asbestos s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Asbestos", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Asbestos::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Asbestos s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Asbestos", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Asbestos::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Asbestos s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Asbestos", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Asbestos::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Asbestos s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Asbestos", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Asbestos::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Asbestos s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Asbestos", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Asbestos::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Asbestos s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Asbestos", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Asbestos::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Asbestos s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Asbestos", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Asbestos::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Asbestos s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Asbestos", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Asbestos::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Asbestos s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Asbestos", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Asbestos::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Asbestos s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod kaltsit {
        use super::*;

        #[test]
        fn test_s3_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Kaltsit", 0.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Kaltsit::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Kaltsit s3 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Kaltsit", 300.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Kaltsit::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Kaltsit s3 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Kaltsit", 0.0, 20.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Kaltsit::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Kaltsit s3 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Kaltsit", 500.0, 30.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Kaltsit::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Kaltsit s3 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Kaltsit", 1000.0, 50.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Kaltsit::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Kaltsit s3 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Kaltsit", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Kaltsit::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Kaltsit s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Kaltsit", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Kaltsit::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Kaltsit s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Kaltsit", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Kaltsit::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Kaltsit s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Kaltsit", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Kaltsit::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Kaltsit s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Kaltsit", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Kaltsit::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Kaltsit s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Kaltsit", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Kaltsit::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Kaltsit s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Kaltsit", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Kaltsit::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Kaltsit s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Kaltsit", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Kaltsit::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Kaltsit s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Kaltsit", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Kaltsit::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Kaltsit s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Kaltsit", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Kaltsit::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Kaltsit s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod cantabile {
        use super::*;

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Cantabile", 0.0, 0.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Cantabile::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Cantabile s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Cantabile", 300.0, 0.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Cantabile::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Cantabile s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Cantabile", 0.0, 20.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Cantabile::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Cantabile s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Cantabile", 500.0, 30.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Cantabile::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Cantabile s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Cantabile", 1000.0, 50.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Cantabile::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Cantabile s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Cantabile", 0.0, 0.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Cantabile::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Cantabile s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Cantabile", 300.0, 0.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Cantabile::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Cantabile s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Cantabile", 0.0, 20.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Cantabile::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Cantabile s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Cantabile", 500.0, 30.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Cantabile::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Cantabile s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Cantabile", 1000.0, 50.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Cantabile::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Cantabile s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod coldshot {
        use super::*;

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Coldshot", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Coldshot::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Coldshot s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Coldshot", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Coldshot::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Coldshot s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Coldshot", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Coldshot::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Coldshot s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Coldshot", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Coldshot::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Coldshot s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Coldshot", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Coldshot::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Coldshot s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Coldshot", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Coldshot::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Coldshot s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Coldshot", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Coldshot::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Coldshot s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Coldshot", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Coldshot::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Coldshot s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Coldshot", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Coldshot::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Coldshot s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Coldshot", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Coldshot::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Coldshot s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod contrail {
        use super::*;

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Contrail", 0.0, 0.0, 0, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, -1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Contrail::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Contrail s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Contrail", 300.0, 0.0, 0, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, -1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Contrail::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Contrail s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Contrail", 0.0, 20.0, 0, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, -1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Contrail::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Contrail s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Contrail", 500.0, 30.0, 0, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, -1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Contrail::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Contrail s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Contrail", 1000.0, 50.0, 0, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, -1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Contrail::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Contrail s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Contrail", 0.0, 0.0, 1, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, -1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Contrail::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Contrail s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Contrail", 300.0, 0.0, 1, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, -1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Contrail::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Contrail s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Contrail", 0.0, 20.0, 1, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, -1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Contrail::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Contrail s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Contrail", 500.0, 30.0, 1, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, -1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Contrail::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Contrail s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Contrail", 1000.0, 50.0, 1, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, -1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Contrail::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Contrail s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod jessica_alter {
        use super::*;

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("JessicaAlter", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = JessicaAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "JessicaAlter s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("JessicaAlter", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = JessicaAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "JessicaAlter s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("JessicaAlter", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = JessicaAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "JessicaAlter s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("JessicaAlter", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = JessicaAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "JessicaAlter s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("JessicaAlter", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = JessicaAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "JessicaAlter s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("JessicaAlter", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = JessicaAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "JessicaAlter s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("JessicaAlter", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = JessicaAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "JessicaAlter s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("JessicaAlter", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = JessicaAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "JessicaAlter s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("JessicaAlter", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = JessicaAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "JessicaAlter s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("JessicaAlter", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = JessicaAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "JessicaAlter s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("JessicaAlter", 0.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = JessicaAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "JessicaAlter s3 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("JessicaAlter", 300.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = JessicaAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "JessicaAlter s3 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("JessicaAlter", 0.0, 20.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = JessicaAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "JessicaAlter s3 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("JessicaAlter", 500.0, 30.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = JessicaAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "JessicaAlter s3 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("JessicaAlter", 1000.0, 50.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = JessicaAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "JessicaAlter s3 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod ray {
        use super::*;

        #[test]
        fn test_s3_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ray", 0.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ray::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ray s3 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ray", 300.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ray::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ray s3 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ray", 0.0, 20.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ray::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ray s3 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ray", 500.0, 30.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ray::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ray s3 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ray", 1000.0, 50.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ray::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ray s3 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ray", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ray::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ray s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ray", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ray::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ray s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ray", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ray::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ray s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ray", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ray::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ray s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ray", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ray::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ray s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ray", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ray::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ray s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ray", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ray::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ray s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ray", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ray::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ray s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ray", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ray::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ray s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ray", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ray::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ray s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod res {
        use super::*;

        #[test]
        fn test_base_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Res", 0.0, 0.0, -1, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(-1, -1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Res::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Res base def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_base_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Res", 300.0, 0.0, -1, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(-1, -1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Res::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Res base def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_base_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Res", 0.0, 20.0, -1, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(-1, -1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Res::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Res base def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_base_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Res", 500.0, 30.0, -1, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(-1, -1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Res::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Res base def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_base_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Res", 1000.0, 50.0, -1, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(-1, -1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Res::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Res base def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod rosa {
        use super::*;

        #[test]
        fn test_s3_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Rosa", 0.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Rosa::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Rosa s3 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Rosa", 300.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Rosa::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Rosa s3 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Rosa", 0.0, 20.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Rosa::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Rosa s3 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Rosa", 500.0, 30.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Rosa::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Rosa s3 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Rosa", 1000.0, 50.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Rosa::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Rosa s3 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Rosa", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Rosa::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Rosa s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Rosa", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Rosa::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Rosa s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Rosa", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Rosa::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Rosa s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Rosa", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Rosa::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Rosa s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Rosa", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Rosa::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Rosa s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Rosa", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Rosa::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Rosa s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Rosa", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Rosa::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Rosa s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Rosa", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Rosa::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Rosa s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Rosa", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Rosa::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Rosa s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Rosa", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Rosa::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Rosa s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod qiubai {
        use super::*;

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Qiubai", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Qiubai::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Qiubai s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Qiubai", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Qiubai::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Qiubai s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Qiubai", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Qiubai::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Qiubai s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Qiubai", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Qiubai::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Qiubai s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Qiubai", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Qiubai::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Qiubai s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Qiubai", 0.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Qiubai::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Qiubai s3 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Qiubai", 300.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Qiubai::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Qiubai s3 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Qiubai", 0.0, 20.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Qiubai::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Qiubai s3 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Qiubai", 500.0, 30.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Qiubai::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Qiubai s3 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Qiubai", 1000.0, 50.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Qiubai::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Qiubai s3 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod eyjafjalla {
        use super::*;

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Eyjafjalla", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Eyjafjalla::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Eyjafjalla s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Eyjafjalla", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Eyjafjalla::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Eyjafjalla s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Eyjafjalla", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Eyjafjalla::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Eyjafjalla s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Eyjafjalla", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Eyjafjalla::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Eyjafjalla s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Eyjafjalla", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Eyjafjalla::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Eyjafjalla s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Eyjafjalla", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Eyjafjalla::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Eyjafjalla s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Eyjafjalla", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Eyjafjalla::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Eyjafjalla s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Eyjafjalla", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Eyjafjalla::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Eyjafjalla s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Eyjafjalla", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Eyjafjalla::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Eyjafjalla s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Eyjafjalla", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Eyjafjalla::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Eyjafjalla s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Eyjafjalla", 0.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Eyjafjalla::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Eyjafjalla s3 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Eyjafjalla", 300.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Eyjafjalla::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Eyjafjalla s3 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Eyjafjalla", 0.0, 20.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Eyjafjalla::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Eyjafjalla s3 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Eyjafjalla", 500.0, 30.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Eyjafjalla::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Eyjafjalla s3 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Eyjafjalla", 1000.0, 50.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Eyjafjalla::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Eyjafjalla s3 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod mlynar {
        use super::*;

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Mlynar", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Mlynar::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Mlynar s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Mlynar", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Mlynar::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Mlynar s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Mlynar", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Mlynar::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Mlynar s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Mlynar", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Mlynar::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Mlynar s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Mlynar", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Mlynar::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Mlynar s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Mlynar", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Mlynar::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Mlynar s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Mlynar", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Mlynar::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Mlynar s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Mlynar", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Mlynar::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Mlynar s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Mlynar", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Mlynar::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Mlynar s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Mlynar", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Mlynar::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Mlynar s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Mlynar", 0.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Mlynar::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Mlynar s3 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Mlynar", 300.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Mlynar::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Mlynar s3 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Mlynar", 0.0, 20.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Mlynar::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Mlynar s3 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Mlynar", 500.0, 30.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Mlynar::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Mlynar s3 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Mlynar", 1000.0, 50.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Mlynar::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Mlynar s3 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod ling {
        use super::*;

        #[test]
        fn test_s3_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ling", 0.0, 0.0, 2, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 2);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ling::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ling s3 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ling", 300.0, 0.0, 2, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 2);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ling::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ling s3 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ling", 0.0, 20.0, 2, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 2);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ling::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ling s3 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ling", 500.0, 30.0, 2, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 2);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ling::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ling s3 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ling", 1000.0, 50.0, 2, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 2);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ling::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ling s3 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ling", 0.0, 0.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ling::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ling s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ling", 300.0, 0.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ling::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ling s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ling", 0.0, 20.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ling::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ling s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ling", 500.0, 30.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ling::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ling s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ling", 1000.0, 50.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ling::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ling s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ling", 0.0, 0.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ling::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ling s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ling", 300.0, 0.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ling::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ling s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ling", 0.0, 20.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ling::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ling s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ling", 500.0, 30.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ling::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ling s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ling", 1000.0, 50.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ling::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ling s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod yahata_umiri {
        use super::*;

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("YahataUmiri", 0.0, 0.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = YahataUmiri::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "YahataUmiri s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("YahataUmiri", 300.0, 0.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = YahataUmiri::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "YahataUmiri s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("YahataUmiri", 0.0, 20.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = YahataUmiri::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "YahataUmiri s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("YahataUmiri", 500.0, 30.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = YahataUmiri::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "YahataUmiri s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("YahataUmiri", 1000.0, 50.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = YahataUmiri::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "YahataUmiri s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("YahataUmiri", 0.0, 0.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = YahataUmiri::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "YahataUmiri s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("YahataUmiri", 300.0, 0.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = YahataUmiri::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "YahataUmiri s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("YahataUmiri", 0.0, 20.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = YahataUmiri::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "YahataUmiri s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("YahataUmiri", 500.0, 30.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = YahataUmiri::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "YahataUmiri s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("YahataUmiri", 1000.0, 50.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = YahataUmiri::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "YahataUmiri s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("YahataUmiri", 0.0, 0.0, 2, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 2);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = YahataUmiri::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "YahataUmiri s3 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("YahataUmiri", 300.0, 0.0, 2, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 2);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = YahataUmiri::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "YahataUmiri s3 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("YahataUmiri", 0.0, 20.0, 2, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 2);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = YahataUmiri::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "YahataUmiri s3 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("YahataUmiri", 500.0, 30.0, 2, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 2);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = YahataUmiri::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "YahataUmiri s3 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("YahataUmiri", 1000.0, 50.0, 2, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 2);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = YahataUmiri::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "YahataUmiri s3 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod terra_research_commission {
        use super::*;

        #[test]
        fn test_base_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("TerraResearchCommission", 0.0, 0.0, -1, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(-1, -1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = TerraResearchCommission::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "TerraResearchCommission base def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_base_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("TerraResearchCommission", 300.0, 0.0, -1, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(-1, -1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = TerraResearchCommission::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "TerraResearchCommission base def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_base_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("TerraResearchCommission", 0.0, 20.0, -1, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(-1, -1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = TerraResearchCommission::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "TerraResearchCommission base def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_base_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("TerraResearchCommission", 500.0, 30.0, -1, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(-1, -1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = TerraResearchCommission::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "TerraResearchCommission base def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_base_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("TerraResearchCommission", 1000.0, 50.0, -1, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(-1, -1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = TerraResearchCommission::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "TerraResearchCommission base def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod ceobe {
        use super::*;

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ceobe", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ceobe::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ceobe s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ceobe", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ceobe::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ceobe s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ceobe", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ceobe::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ceobe s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ceobe", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ceobe::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ceobe s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ceobe", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ceobe::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ceobe s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ceobe", 0.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ceobe::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ceobe s3 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ceobe", 300.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ceobe::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ceobe s3 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ceobe", 0.0, 20.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ceobe::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ceobe s3 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ceobe", 500.0, 30.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ceobe::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ceobe s3 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ceobe", 1000.0, 50.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ceobe::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ceobe s3 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ceobe", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ceobe::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ceobe s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ceobe", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ceobe::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ceobe s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ceobe", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ceobe::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ceobe s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ceobe", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ceobe::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ceobe s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ceobe", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ceobe::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ceobe s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod provence {
        use super::*;

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Provence", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Provence::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Provence s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Provence", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Provence::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Provence s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Provence", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Provence::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Provence s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Provence", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Provence::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Provence s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Provence", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Provence::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Provence s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Provence", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Provence::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Provence s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Provence", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Provence::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Provence s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Provence", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Provence::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Provence s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Provence", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Provence::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Provence s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Provence", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Provence::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Provence s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod amiya {
        use super::*;

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Amiya", 0.0, 0.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Amiya::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Amiya s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Amiya", 300.0, 0.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Amiya::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Amiya s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Amiya", 0.0, 20.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Amiya::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Amiya s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Amiya", 500.0, 30.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Amiya::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Amiya s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Amiya", 1000.0, 50.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Amiya::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Amiya s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Amiya", 0.0, 0.0, 2, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 2);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Amiya::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Amiya s3 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Amiya", 300.0, 0.0, 2, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 2);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Amiya::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Amiya s3 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Amiya", 0.0, 20.0, 2, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 2);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Amiya::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Amiya s3 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Amiya", 500.0, 30.0, 2, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 2);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Amiya::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Amiya s3 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Amiya", 1000.0, 50.0, 2, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 2);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Amiya::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Amiya s3 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Amiya", 0.0, 0.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Amiya::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Amiya s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Amiya", 300.0, 0.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Amiya::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Amiya s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Amiya", 0.0, 20.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Amiya::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Amiya s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Amiya", 500.0, 30.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Amiya::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Amiya s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Amiya", 1000.0, 50.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Amiya::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Amiya s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod chongyue {
        use super::*;

        #[test]
        fn test_s3_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Chongyue", 0.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Chongyue::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Chongyue s3 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Chongyue", 300.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Chongyue::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Chongyue s3 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Chongyue", 0.0, 20.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Chongyue::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Chongyue s3 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Chongyue", 500.0, 30.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Chongyue::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Chongyue s3 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Chongyue", 1000.0, 50.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Chongyue::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Chongyue s3 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Chongyue", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Chongyue::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Chongyue s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Chongyue", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Chongyue::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Chongyue s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Chongyue", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Chongyue::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Chongyue s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Chongyue", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Chongyue::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Chongyue s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Chongyue", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Chongyue::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Chongyue s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod minimalist {
        use super::*;

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Minimalist", 0.0, 0.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Minimalist::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Minimalist s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Minimalist", 300.0, 0.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Minimalist::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Minimalist s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Minimalist", 0.0, 20.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Minimalist::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Minimalist s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Minimalist", 500.0, 30.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Minimalist::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Minimalist s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Minimalist", 1000.0, 50.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Minimalist::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Minimalist s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Minimalist", 0.0, 0.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Minimalist::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Minimalist s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Minimalist", 300.0, 0.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Minimalist::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Minimalist s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Minimalist", 0.0, 20.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Minimalist::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Minimalist s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Minimalist", 500.0, 30.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Minimalist::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Minimalist s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Minimalist", 1000.0, 50.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Minimalist::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Minimalist s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod flint {
        use super::*;

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Flint", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Flint::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Flint s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Flint", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Flint::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Flint s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Flint", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Flint::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Flint s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Flint", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Flint::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Flint s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Flint", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Flint::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Flint s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Flint", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Flint::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Flint s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Flint", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Flint::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Flint s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Flint", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Flint::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Flint s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Flint", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Flint::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Flint s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Flint", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Flint::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Flint s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod chen {
        use super::*;

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Chen", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Chen::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Chen s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Chen", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Chen::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Chen s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Chen", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Chen::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Chen s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Chen", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Chen::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Chen s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Chen", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Chen::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Chen s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Chen", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Chen::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Chen s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Chen", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Chen::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Chen s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Chen", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Chen::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Chen s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Chen", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Chen::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Chen s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Chen", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Chen::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Chen s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Chen", 0.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Chen::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Chen s3 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Chen", 300.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Chen::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Chen s3 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Chen", 0.0, 20.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Chen::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Chen s3 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Chen", 500.0, 30.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Chen::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Chen s3 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Chen", 1000.0, 50.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Chen::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Chen s3 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod tequila {
        use super::*;

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Tequila", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Tequila::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Tequila s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Tequila", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Tequila::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Tequila s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Tequila", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Tequila::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Tequila s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Tequila", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Tequila::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Tequila s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Tequila", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Tequila::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Tequila s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Tequila", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Tequila::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Tequila s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Tequila", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Tequila::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Tequila s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Tequila", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Tequila::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Tequila s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Tequila", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Tequila::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Tequila s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Tequila", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Tequila::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Tequila s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod underflow {
        use super::*;

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Underflow", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Underflow::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Underflow s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Underflow", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Underflow::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Underflow s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Underflow", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Underflow::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Underflow s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Underflow", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Underflow::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Underflow s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Underflow", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Underflow::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Underflow s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Underflow", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Underflow::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Underflow s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Underflow", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Underflow::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Underflow s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Underflow", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Underflow::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Underflow s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Underflow", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Underflow::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Underflow s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Underflow", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Underflow::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Underflow s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod hoolheyak {
        use super::*;

        #[test]
        fn test_s3_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Hoolheyak", 0.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Hoolheyak::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Hoolheyak s3 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Hoolheyak", 300.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Hoolheyak::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Hoolheyak s3 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Hoolheyak", 0.0, 20.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Hoolheyak::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Hoolheyak s3 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Hoolheyak", 500.0, 30.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Hoolheyak::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Hoolheyak s3 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Hoolheyak", 1000.0, 50.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Hoolheyak::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Hoolheyak s3 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Hoolheyak", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Hoolheyak::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Hoolheyak s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Hoolheyak", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Hoolheyak::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Hoolheyak s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Hoolheyak", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Hoolheyak::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Hoolheyak s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Hoolheyak", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Hoolheyak::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Hoolheyak s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Hoolheyak", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Hoolheyak::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Hoolheyak s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Hoolheyak", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Hoolheyak::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Hoolheyak s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Hoolheyak", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Hoolheyak::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Hoolheyak s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Hoolheyak", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Hoolheyak::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Hoolheyak s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Hoolheyak", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Hoolheyak::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Hoolheyak s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Hoolheyak", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Hoolheyak::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Hoolheyak s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod lin {
        use super::*;

        #[test]
        fn test_s3_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Lin", 0.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Lin::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Lin s3 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Lin", 300.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Lin::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Lin s3 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Lin", 0.0, 20.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Lin::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Lin s3 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Lin", 500.0, 30.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Lin::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Lin s3 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Lin", 1000.0, 50.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Lin::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Lin s3 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Lin", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Lin::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Lin s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Lin", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Lin::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Lin s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Lin", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Lin::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Lin s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Lin", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Lin::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Lin s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Lin", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Lin::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Lin s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Lin", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Lin::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Lin s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Lin", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Lin::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Lin s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Lin", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Lin::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Lin s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Lin", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Lin::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Lin s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Lin", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Lin::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Lin s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod steward {
        use super::*;

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Steward", 0.0, 0.0, 0, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, -1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Steward::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Steward s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Steward", 300.0, 0.0, 0, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, -1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Steward::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Steward s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Steward", 0.0, 20.0, 0, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, -1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Steward::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Steward s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Steward", 500.0, 30.0, 0, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, -1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Steward::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Steward s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Steward", 1000.0, 50.0, 0, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, -1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Steward::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Steward s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod pramanix_alter {
        use super::*;

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("PramanixAlter", 0.0, 0.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = PramanixAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "PramanixAlter s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("PramanixAlter", 300.0, 0.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = PramanixAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "PramanixAlter s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("PramanixAlter", 0.0, 20.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = PramanixAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "PramanixAlter s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("PramanixAlter", 500.0, 30.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = PramanixAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "PramanixAlter s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("PramanixAlter", 1000.0, 50.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = PramanixAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "PramanixAlter s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("PramanixAlter", 0.0, 0.0, 2, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 2);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = PramanixAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "PramanixAlter s3 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("PramanixAlter", 300.0, 0.0, 2, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 2);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = PramanixAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "PramanixAlter s3 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("PramanixAlter", 0.0, 20.0, 2, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 2);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = PramanixAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "PramanixAlter s3 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("PramanixAlter", 500.0, 30.0, 2, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 2);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = PramanixAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "PramanixAlter s3 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("PramanixAlter", 1000.0, 50.0, 2, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 2);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = PramanixAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "PramanixAlter s3 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("PramanixAlter", 0.0, 0.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = PramanixAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "PramanixAlter s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("PramanixAlter", 300.0, 0.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = PramanixAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "PramanixAlter s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("PramanixAlter", 0.0, 20.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = PramanixAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "PramanixAlter s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("PramanixAlter", 500.0, 30.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = PramanixAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "PramanixAlter s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("PramanixAlter", 1000.0, 50.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = PramanixAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "PramanixAlter s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod lessing {
        use super::*;

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Lessing", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Lessing::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Lessing s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Lessing", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Lessing::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Lessing s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Lessing", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Lessing::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Lessing s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Lessing", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Lessing::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Lessing s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Lessing", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Lessing::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Lessing s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Lessing", 0.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Lessing::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Lessing s3 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Lessing", 300.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Lessing::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Lessing s3 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Lessing", 0.0, 20.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Lessing::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Lessing s3 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Lessing", 500.0, 30.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Lessing::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Lessing s3 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Lessing", 1000.0, 50.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Lessing::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Lessing s3 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Lessing", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Lessing::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Lessing s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Lessing", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Lessing::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Lessing s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Lessing", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Lessing::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Lessing s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Lessing", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Lessing::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Lessing s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Lessing", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Lessing::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Lessing s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod bagpipe {
        use super::*;

        #[test]
        fn test_s3_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Bagpipe", 0.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Bagpipe::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Bagpipe s3 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Bagpipe", 300.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Bagpipe::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Bagpipe s3 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Bagpipe", 0.0, 20.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Bagpipe::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Bagpipe s3 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Bagpipe", 500.0, 30.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Bagpipe::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Bagpipe s3 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Bagpipe", 1000.0, 50.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Bagpipe::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Bagpipe s3 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Bagpipe", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Bagpipe::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Bagpipe s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Bagpipe", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Bagpipe::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Bagpipe s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Bagpipe", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Bagpipe::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Bagpipe s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Bagpipe", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Bagpipe::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Bagpipe s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Bagpipe", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Bagpipe::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Bagpipe s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Bagpipe", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Bagpipe::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Bagpipe s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Bagpipe", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Bagpipe::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Bagpipe s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Bagpipe", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Bagpipe::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Bagpipe s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Bagpipe", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Bagpipe::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Bagpipe s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Bagpipe", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Bagpipe::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Bagpipe s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod kirara {
        use super::*;

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Kirara", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Kirara::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Kirara s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Kirara", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Kirara::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Kirara s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Kirara", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Kirara::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Kirara s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Kirara", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Kirara::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Kirara s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Kirara", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Kirara::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Kirara s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Kirara", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Kirara::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Kirara s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Kirara", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Kirara::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Kirara s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Kirara", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Kirara::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Kirara s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Kirara", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Kirara::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Kirara s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Kirara", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Kirara::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Kirara s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod grey_throat {
        use super::*;

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("GreyThroat", 0.0, 0.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = GreyThroat::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "GreyThroat s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("GreyThroat", 300.0, 0.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = GreyThroat::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "GreyThroat s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("GreyThroat", 0.0, 20.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = GreyThroat::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "GreyThroat s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("GreyThroat", 500.0, 30.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = GreyThroat::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "GreyThroat s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("GreyThroat", 1000.0, 50.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = GreyThroat::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "GreyThroat s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("GreyThroat", 0.0, 0.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = GreyThroat::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "GreyThroat s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("GreyThroat", 300.0, 0.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = GreyThroat::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "GreyThroat s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("GreyThroat", 0.0, 20.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = GreyThroat::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "GreyThroat s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("GreyThroat", 500.0, 30.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = GreyThroat::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "GreyThroat s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("GreyThroat", 1000.0, 50.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = GreyThroat::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "GreyThroat s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod mint {
        use super::*;

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Mint", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Mint::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Mint s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Mint", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Mint::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Mint s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Mint", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Mint::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Mint s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Mint", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Mint::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Mint s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Mint", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Mint::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Mint s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Mint", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Mint::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Mint s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Mint", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Mint::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Mint s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Mint", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Mint::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Mint s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Mint", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Mint::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Mint s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Mint", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Mint::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Mint s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod degenbrecher {
        use super::*;

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Degenbrecher", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Degenbrecher::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Degenbrecher s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Degenbrecher", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Degenbrecher::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Degenbrecher s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Degenbrecher", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Degenbrecher::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Degenbrecher s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Degenbrecher", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Degenbrecher::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Degenbrecher s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Degenbrecher", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Degenbrecher::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Degenbrecher s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Degenbrecher", 0.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Degenbrecher::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Degenbrecher s3 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Degenbrecher", 300.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Degenbrecher::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Degenbrecher s3 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Degenbrecher", 0.0, 20.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Degenbrecher::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Degenbrecher s3 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Degenbrecher", 500.0, 30.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Degenbrecher::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Degenbrecher s3 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Degenbrecher", 1000.0, 50.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Degenbrecher::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Degenbrecher s3 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod bibeak {
        use super::*;

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Bibeak", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Bibeak::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Bibeak s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Bibeak", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Bibeak::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Bibeak s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Bibeak", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Bibeak::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Bibeak s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Bibeak", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Bibeak::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Bibeak s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Bibeak", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Bibeak::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Bibeak s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Bibeak", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Bibeak::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Bibeak s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Bibeak", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Bibeak::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Bibeak s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Bibeak", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Bibeak::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Bibeak s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Bibeak", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Bibeak::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Bibeak s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Bibeak", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Bibeak::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Bibeak s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod surtr {
        use super::*;

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Surtr", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Surtr::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Surtr s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Surtr", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Surtr::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Surtr s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Surtr", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Surtr::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Surtr s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Surtr", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Surtr::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Surtr s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Surtr", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Surtr::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Surtr s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Surtr", 0.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Surtr::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Surtr s3 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Surtr", 300.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Surtr::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Surtr s3 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Surtr", 0.0, 20.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Surtr::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Surtr s3 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Surtr", 500.0, 30.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Surtr::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Surtr s3 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Surtr", 1000.0, 50.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Surtr::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Surtr s3 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Surtr", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Surtr::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Surtr s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Surtr", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Surtr::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Surtr s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Surtr", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Surtr::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Surtr s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Surtr", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Surtr::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Surtr s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Surtr", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Surtr::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Surtr s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod platinum {
        use super::*;

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Platinum", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Platinum::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Platinum s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Platinum", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Platinum::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Platinum s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Platinum", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Platinum::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Platinum s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Platinum", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Platinum::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Platinum s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Platinum", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Platinum::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Platinum s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Platinum", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Platinum::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Platinum s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Platinum", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Platinum::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Platinum s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Platinum", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Platinum::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Platinum s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Platinum", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Platinum::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Platinum s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Platinum", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Platinum::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Platinum s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod beeswax {
        use super::*;

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Beeswax", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Beeswax::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Beeswax s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Beeswax", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Beeswax::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Beeswax s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Beeswax", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Beeswax::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Beeswax s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Beeswax", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Beeswax::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Beeswax s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Beeswax", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Beeswax::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Beeswax s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Beeswax", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Beeswax::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Beeswax s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Beeswax", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Beeswax::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Beeswax s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Beeswax", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Beeswax::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Beeswax s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Beeswax", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Beeswax::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Beeswax s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Beeswax", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Beeswax::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Beeswax s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod pudding {
        use super::*;

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Pudding", 0.0, 0.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Pudding::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Pudding s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Pudding", 300.0, 0.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Pudding::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Pudding s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Pudding", 0.0, 20.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Pudding::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Pudding s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Pudding", 500.0, 30.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Pudding::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Pudding s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Pudding", 1000.0, 50.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Pudding::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Pudding s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Pudding", 0.0, 0.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Pudding::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Pudding s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Pudding", 300.0, 0.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Pudding::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Pudding s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Pudding", 0.0, 20.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Pudding::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Pudding s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Pudding", 500.0, 30.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Pudding::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Pudding s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Pudding", 1000.0, 50.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Pudding::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Pudding s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod rockrock {
        use super::*;

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Rockrock", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Rockrock::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Rockrock s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Rockrock", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Rockrock::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Rockrock s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Rockrock", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Rockrock::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Rockrock s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Rockrock", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Rockrock::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Rockrock s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Rockrock", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Rockrock::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Rockrock s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Rockrock", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Rockrock::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Rockrock s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Rockrock", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Rockrock::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Rockrock s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Rockrock", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Rockrock::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Rockrock s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Rockrock", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Rockrock::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Rockrock s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Rockrock", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Rockrock::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Rockrock s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod marcille {
        use super::*;

        #[test]
        fn test_s3_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Marcille", 0.0, 0.0, 2, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 2);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Marcille::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Marcille s3 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Marcille", 300.0, 0.0, 2, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 2);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Marcille::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Marcille s3 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Marcille", 0.0, 20.0, 2, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 2);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Marcille::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Marcille s3 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Marcille", 500.0, 30.0, 2, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 2);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Marcille::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Marcille s3 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Marcille", 1000.0, 50.0, 2, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 2);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Marcille::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Marcille s3 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Marcille", 0.0, 0.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Marcille::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Marcille s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Marcille", 300.0, 0.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Marcille::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Marcille s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Marcille", 0.0, 20.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Marcille::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Marcille s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Marcille", 500.0, 30.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Marcille::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Marcille s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Marcille", 1000.0, 50.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Marcille::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Marcille s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Marcille", 0.0, 0.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Marcille::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Marcille s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Marcille", 300.0, 0.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Marcille::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Marcille s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Marcille", 0.0, 20.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Marcille::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Marcille s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Marcille", 500.0, 30.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Marcille::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Marcille s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Marcille", 1000.0, 50.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Marcille::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Marcille s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod toddifons {
        use super::*;

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Toddifons", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Toddifons::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Toddifons s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Toddifons", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Toddifons::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Toddifons s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Toddifons", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Toddifons::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Toddifons s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Toddifons", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Toddifons::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Toddifons s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Toddifons", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Toddifons::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Toddifons s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Toddifons", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Toddifons::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Toddifons s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Toddifons", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Toddifons::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Toddifons s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Toddifons", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Toddifons::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Toddifons s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Toddifons", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Toddifons::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Toddifons s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Toddifons", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Toddifons::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Toddifons s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod leto {
        use super::*;

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Leto", 0.0, 0.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Leto::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Leto s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Leto", 300.0, 0.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Leto::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Leto s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Leto", 0.0, 20.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Leto::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Leto s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Leto", 500.0, 30.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Leto::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Leto s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Leto", 1000.0, 50.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Leto::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Leto s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Leto", 0.0, 0.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Leto::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Leto s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Leto", 300.0, 0.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Leto::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Leto s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Leto", 0.0, 20.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Leto::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Leto s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Leto", 500.0, 30.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Leto::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Leto s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Leto", 1000.0, 50.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Leto::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Leto s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod togawa_sakiko {
        use super::*;

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("TogawaSakiko", 0.0, 0.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = TogawaSakiko::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "TogawaSakiko s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("TogawaSakiko", 300.0, 0.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = TogawaSakiko::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "TogawaSakiko s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("TogawaSakiko", 0.0, 20.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = TogawaSakiko::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "TogawaSakiko s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("TogawaSakiko", 500.0, 30.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = TogawaSakiko::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "TogawaSakiko s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("TogawaSakiko", 1000.0, 50.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = TogawaSakiko::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "TogawaSakiko s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("TogawaSakiko", 0.0, 0.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = TogawaSakiko::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "TogawaSakiko s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("TogawaSakiko", 300.0, 0.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = TogawaSakiko::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "TogawaSakiko s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("TogawaSakiko", 0.0, 20.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = TogawaSakiko::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "TogawaSakiko s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("TogawaSakiko", 500.0, 30.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = TogawaSakiko::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "TogawaSakiko s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("TogawaSakiko", 1000.0, 50.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = TogawaSakiko::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "TogawaSakiko s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("TogawaSakiko", 0.0, 0.0, 2, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 2);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = TogawaSakiko::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "TogawaSakiko s3 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("TogawaSakiko", 300.0, 0.0, 2, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 2);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = TogawaSakiko::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "TogawaSakiko s3 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("TogawaSakiko", 0.0, 20.0, 2, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 2);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = TogawaSakiko::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "TogawaSakiko s3 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("TogawaSakiko", 500.0, 30.0, 2, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 2);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = TogawaSakiko::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "TogawaSakiko s3 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("TogawaSakiko", 1000.0, 50.0, 2, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 2);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = TogawaSakiko::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "TogawaSakiko s3 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod sankta_miksaparato {
        use super::*;

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("SanktaMiksaparato", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = SanktaMiksaparato::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "SanktaMiksaparato s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("SanktaMiksaparato", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = SanktaMiksaparato::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "SanktaMiksaparato s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("SanktaMiksaparato", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = SanktaMiksaparato::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "SanktaMiksaparato s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("SanktaMiksaparato", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = SanktaMiksaparato::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "SanktaMiksaparato s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("SanktaMiksaparato", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = SanktaMiksaparato::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "SanktaMiksaparato s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("SanktaMiksaparato", 0.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = SanktaMiksaparato::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "SanktaMiksaparato s3 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("SanktaMiksaparato", 300.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = SanktaMiksaparato::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "SanktaMiksaparato s3 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("SanktaMiksaparato", 0.0, 20.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = SanktaMiksaparato::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "SanktaMiksaparato s3 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("SanktaMiksaparato", 500.0, 30.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = SanktaMiksaparato::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "SanktaMiksaparato s3 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("SanktaMiksaparato", 1000.0, 50.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = SanktaMiksaparato::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "SanktaMiksaparato s3 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("SanktaMiksaparato", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = SanktaMiksaparato::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "SanktaMiksaparato s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("SanktaMiksaparato", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = SanktaMiksaparato::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "SanktaMiksaparato s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("SanktaMiksaparato", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = SanktaMiksaparato::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "SanktaMiksaparato s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("SanktaMiksaparato", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = SanktaMiksaparato::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "SanktaMiksaparato s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("SanktaMiksaparato", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = SanktaMiksaparato::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "SanktaMiksaparato s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod adnachiel {
        use super::*;

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Adnachiel", 0.0, 0.0, 0, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, -1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Adnachiel::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Adnachiel s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Adnachiel", 300.0, 0.0, 0, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, -1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Adnachiel::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Adnachiel s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Adnachiel", 0.0, 20.0, 0, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, -1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Adnachiel::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Adnachiel s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Adnachiel", 500.0, 30.0, 0, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, -1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Adnachiel::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Adnachiel s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Adnachiel", 1000.0, 50.0, 0, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, -1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Adnachiel::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Adnachiel s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod harmonie {
        use super::*;

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Harmonie", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Harmonie::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Harmonie s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Harmonie", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Harmonie::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Harmonie s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Harmonie", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Harmonie::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Harmonie s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Harmonie", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Harmonie::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Harmonie s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Harmonie", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Harmonie::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Harmonie s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Harmonie", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Harmonie::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Harmonie s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Harmonie", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Harmonie::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Harmonie s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Harmonie", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Harmonie::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Harmonie s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Harmonie", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Harmonie::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Harmonie s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Harmonie", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Harmonie::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Harmonie s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod melantha {
        use super::*;

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Melantha", 0.0, 0.0, 0, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, -1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Melantha::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Melantha s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Melantha", 300.0, 0.0, 0, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, -1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Melantha::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Melantha s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Melantha", 0.0, 20.0, 0, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, -1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Melantha::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Melantha s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Melantha", 500.0, 30.0, 0, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, -1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Melantha::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Melantha s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Melantha", 1000.0, 50.0, 0, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, -1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Melantha::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Melantha s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod jessica {
        use super::*;

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Jessica", 0.0, 0.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Jessica::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Jessica s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Jessica", 300.0, 0.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Jessica::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Jessica s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Jessica", 0.0, 20.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Jessica::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Jessica s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Jessica", 500.0, 30.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Jessica::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Jessica s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Jessica", 1000.0, 50.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Jessica::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Jessica s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Jessica", 0.0, 0.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Jessica::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Jessica s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Jessica", 300.0, 0.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Jessica::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Jessica s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Jessica", 0.0, 20.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Jessica::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Jessica s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Jessica", 500.0, 30.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Jessica::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Jessica s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Jessica", 1000.0, 50.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Jessica::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Jessica s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod tragodia {
        use super::*;

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Tragodia", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Tragodia::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Tragodia s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Tragodia", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Tragodia::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Tragodia s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Tragodia", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Tragodia::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Tragodia s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Tragodia", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Tragodia::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Tragodia s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Tragodia", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Tragodia::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Tragodia s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Tragodia", 0.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Tragodia::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Tragodia s3 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Tragodia", 300.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Tragodia::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Tragodia s3 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Tragodia", 0.0, 20.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Tragodia::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Tragodia s3 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Tragodia", 500.0, 30.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Tragodia::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Tragodia s3 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Tragodia", 1000.0, 50.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Tragodia::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Tragodia s3 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Tragodia", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Tragodia::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Tragodia s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Tragodia", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Tragodia::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Tragodia s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Tragodia", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Tragodia::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Tragodia s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Tragodia", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Tragodia::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Tragodia s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Tragodia", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Tragodia::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Tragodia s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod gavial_alter {
        use super::*;

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("GavialAlter", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = GavialAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "GavialAlter s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("GavialAlter", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = GavialAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "GavialAlter s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("GavialAlter", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = GavialAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "GavialAlter s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("GavialAlter", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = GavialAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "GavialAlter s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("GavialAlter", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = GavialAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "GavialAlter s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("GavialAlter", 0.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = GavialAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "GavialAlter s3 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("GavialAlter", 300.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = GavialAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "GavialAlter s3 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("GavialAlter", 0.0, 20.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = GavialAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "GavialAlter s3 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("GavialAlter", 500.0, 30.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = GavialAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "GavialAlter s3 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("GavialAlter", 1000.0, 50.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = GavialAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "GavialAlter s3 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("GavialAlter", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = GavialAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "GavialAlter s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("GavialAlter", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = GavialAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "GavialAlter s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("GavialAlter", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = GavialAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "GavialAlter s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("GavialAlter", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = GavialAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "GavialAlter s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("GavialAlter", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = GavialAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "GavialAlter s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod misumi_uika {
        use super::*;

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("MisumiUika", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = MisumiUika::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "MisumiUika s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("MisumiUika", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = MisumiUika::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "MisumiUika s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("MisumiUika", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = MisumiUika::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "MisumiUika s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("MisumiUika", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = MisumiUika::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "MisumiUika s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("MisumiUika", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = MisumiUika::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "MisumiUika s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod whislash {
        use super::*;

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Whislash", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Whislash::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Whislash s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Whislash", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Whislash::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Whislash s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Whislash", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Whislash::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Whislash s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Whislash", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Whislash::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Whislash s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Whislash", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Whislash::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Whislash s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Whislash", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Whislash::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Whislash s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Whislash", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Whislash::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Whislash s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Whislash", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Whislash::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Whislash s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Whislash", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Whislash::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Whislash s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Whislash", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Whislash::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Whislash s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod passenger {
        use super::*;

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Passenger", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Passenger::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Passenger s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Passenger", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Passenger::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Passenger s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Passenger", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Passenger::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Passenger s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Passenger", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Passenger::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Passenger s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Passenger", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Passenger::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Passenger s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Passenger", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Passenger::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Passenger s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Passenger", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Passenger::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Passenger s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Passenger", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Passenger::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Passenger s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Passenger", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Passenger::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Passenger s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Passenger", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Passenger::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Passenger s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Passenger", 0.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Passenger::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Passenger s3 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Passenger", 300.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Passenger::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Passenger s3 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Passenger", 0.0, 20.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Passenger::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Passenger s3 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Passenger", 500.0, 30.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Passenger::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Passenger s3 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Passenger", 1000.0, 50.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Passenger::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Passenger s3 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod sand_reckoner {
        use super::*;

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("SandReckoner", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = SandReckoner::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "SandReckoner s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("SandReckoner", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = SandReckoner::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "SandReckoner s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("SandReckoner", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = SandReckoner::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "SandReckoner s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("SandReckoner", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = SandReckoner::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "SandReckoner s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("SandReckoner", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = SandReckoner::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "SandReckoner s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("SandReckoner", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = SandReckoner::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "SandReckoner s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("SandReckoner", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = SandReckoner::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "SandReckoner s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("SandReckoner", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = SandReckoner::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "SandReckoner s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("SandReckoner", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = SandReckoner::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "SandReckoner s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("SandReckoner", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = SandReckoner::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "SandReckoner s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod scene {
        use super::*;

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Scene", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Scene::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Scene s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Scene", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Scene::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Scene s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Scene", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Scene::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Scene s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Scene", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Scene::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Scene s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Scene", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Scene::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Scene s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Scene", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Scene::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Scene s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Scene", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Scene::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Scene s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Scene", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Scene::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Scene s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Scene", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Scene::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Scene s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Scene", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Scene::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Scene s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod tomimi {
        use super::*;

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Tomimi", 0.0, 0.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Tomimi::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Tomimi s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Tomimi", 300.0, 0.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Tomimi::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Tomimi s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Tomimi", 0.0, 20.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Tomimi::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Tomimi s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Tomimi", 500.0, 30.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Tomimi::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Tomimi s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Tomimi", 1000.0, 50.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Tomimi::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Tomimi s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Tomimi", 0.0, 0.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Tomimi::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Tomimi s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Tomimi", 300.0, 0.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Tomimi::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Tomimi s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Tomimi", 0.0, 20.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Tomimi::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Tomimi s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Tomimi", 500.0, 30.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Tomimi::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Tomimi s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Tomimi", 1000.0, 50.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Tomimi::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Tomimi s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod vigna {
        use super::*;

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Vigna", 0.0, 0.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Vigna::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Vigna s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Vigna", 300.0, 0.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Vigna::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Vigna s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Vigna", 0.0, 20.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Vigna::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Vigna s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Vigna", 500.0, 30.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Vigna::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Vigna s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Vigna", 1000.0, 50.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Vigna::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Vigna s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Vigna", 0.0, 0.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Vigna::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Vigna s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Vigna", 300.0, 0.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Vigna::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Vigna s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Vigna", 0.0, 20.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Vigna::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Vigna s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Vigna", 500.0, 30.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Vigna::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Vigna s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Vigna", 1000.0, 50.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Vigna::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Vigna s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod astgenne {
        use super::*;

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Astgenne", 0.0, 0.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Astgenne::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Astgenne s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Astgenne", 300.0, 0.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Astgenne::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Astgenne s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Astgenne", 0.0, 20.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Astgenne::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Astgenne s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Astgenne", 500.0, 30.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Astgenne::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Astgenne s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Astgenne", 1000.0, 50.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Astgenne::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Astgenne s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Astgenne", 0.0, 0.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Astgenne::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Astgenne s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Astgenne", 300.0, 0.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Astgenne::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Astgenne s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Astgenne", 0.0, 20.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Astgenne::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Astgenne s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Astgenne", 500.0, 30.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Astgenne::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Astgenne s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Astgenne", 1000.0, 50.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Astgenne::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Astgenne s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod yu {
        use super::*;

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Yu", 0.0, 0.0, 1, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, -1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Yu::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Yu s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Yu", 300.0, 0.0, 1, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, -1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Yu::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Yu s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Yu", 0.0, 20.0, 1, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, -1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Yu::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Yu s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Yu", 500.0, 30.0, 1, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, -1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Yu::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Yu s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Yu", 1000.0, 50.0, 1, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, -1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Yu::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Yu s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod flamebringer {
        use super::*;

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Flamebringer", 0.0, 0.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Flamebringer::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Flamebringer s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Flamebringer", 300.0, 0.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Flamebringer::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Flamebringer s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Flamebringer", 0.0, 20.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Flamebringer::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Flamebringer s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Flamebringer", 500.0, 30.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Flamebringer::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Flamebringer s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Flamebringer", 1000.0, 50.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Flamebringer::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Flamebringer s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Flamebringer", 0.0, 0.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Flamebringer::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Flamebringer s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Flamebringer", 300.0, 0.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Flamebringer::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Flamebringer s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Flamebringer", 0.0, 20.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Flamebringer::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Flamebringer s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Flamebringer", 500.0, 30.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Flamebringer::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Flamebringer s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Flamebringer", 1000.0, 50.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Flamebringer::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Flamebringer s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod justice_knight {
        use super::*;

        #[test]
        fn test_base_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("JusticeKnight", 0.0, 0.0, -1, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(-1, -1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = JusticeKnight::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "JusticeKnight base def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_base_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("JusticeKnight", 300.0, 0.0, -1, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(-1, -1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = JusticeKnight::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "JusticeKnight base def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_base_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("JusticeKnight", 0.0, 20.0, -1, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(-1, -1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = JusticeKnight::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "JusticeKnight base def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_base_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("JusticeKnight", 500.0, 30.0, -1, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(-1, -1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = JusticeKnight::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "JusticeKnight base def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_base_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("JusticeKnight", 1000.0, 50.0, -1, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(-1, -1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = JusticeKnight::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "JusticeKnight base def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod kroos_alter {
        use super::*;

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("KroosAlter", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = KroosAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "KroosAlter s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("KroosAlter", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = KroosAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "KroosAlter s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("KroosAlter", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = KroosAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "KroosAlter s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("KroosAlter", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = KroosAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "KroosAlter s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("KroosAlter", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = KroosAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "KroosAlter s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("KroosAlter", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = KroosAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "KroosAlter s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("KroosAlter", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = KroosAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "KroosAlter s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("KroosAlter", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = KroosAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "KroosAlter s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("KroosAlter", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = KroosAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "KroosAlter s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("KroosAlter", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = KroosAlter::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "KroosAlter s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod exusiai {
        use super::*;

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Exusiai", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Exusiai::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Exusiai s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Exusiai", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Exusiai::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Exusiai s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Exusiai", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Exusiai::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Exusiai s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Exusiai", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Exusiai::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Exusiai s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Exusiai", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Exusiai::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Exusiai s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Exusiai", 0.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Exusiai::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Exusiai s3 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Exusiai", 300.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Exusiai::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Exusiai s3 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Exusiai", 0.0, 20.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Exusiai::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Exusiai s3 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Exusiai", 500.0, 30.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Exusiai::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Exusiai s3 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Exusiai", 1000.0, 50.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Exusiai::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Exusiai s3 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Exusiai", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Exusiai::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Exusiai s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Exusiai", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Exusiai::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Exusiai s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Exusiai", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Exusiai::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Exusiai s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Exusiai", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Exusiai::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Exusiai s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Exusiai", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Exusiai::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Exusiai s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod ines {
        use super::*;

        #[test]
        fn test_s3_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ines", 0.0, 0.0, 2, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 2);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ines::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ines s3 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ines", 300.0, 0.0, 2, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 2);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ines::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ines s3 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ines", 0.0, 20.0, 2, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 2);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ines::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ines s3 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ines", 500.0, 30.0, 2, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 2);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ines::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ines s3 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ines", 1000.0, 50.0, 2, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 2);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ines::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ines s3 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ines", 0.0, 0.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ines::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ines s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ines", 300.0, 0.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ines::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ines s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ines", 0.0, 20.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ines::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ines s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ines", 500.0, 30.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ines::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ines s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ines", 1000.0, 50.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ines::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ines s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ines", 0.0, 0.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ines::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ines s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ines", 300.0, 0.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ines::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ines s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ines", 0.0, 20.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ines::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ines s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ines", 500.0, 30.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ines::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ines s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ines", 1000.0, 50.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ines::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ines s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod kroos {
        use super::*;

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Kroos", 0.0, 0.0, 0, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, -1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Kroos::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Kroos s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Kroos", 300.0, 0.0, 0, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, -1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Kroos::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Kroos s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Kroos", 0.0, 20.0, 0, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, -1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Kroos::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Kroos s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Kroos", 500.0, 30.0, 0, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, -1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Kroos::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Kroos s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Kroos", 1000.0, 50.0, 0, -1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, -1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Kroos::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Kroos s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod amiya_guard {
        use super::*;

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("AmiyaGuard", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = AmiyaGuard::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "AmiyaGuard s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("AmiyaGuard", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = AmiyaGuard::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "AmiyaGuard s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("AmiyaGuard", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = AmiyaGuard::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "AmiyaGuard s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("AmiyaGuard", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = AmiyaGuard::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "AmiyaGuard s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("AmiyaGuard", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = AmiyaGuard::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "AmiyaGuard s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("AmiyaGuard", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = AmiyaGuard::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "AmiyaGuard s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("AmiyaGuard", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = AmiyaGuard::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "AmiyaGuard s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("AmiyaGuard", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = AmiyaGuard::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "AmiyaGuard s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("AmiyaGuard", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = AmiyaGuard::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "AmiyaGuard s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("AmiyaGuard", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = AmiyaGuard::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "AmiyaGuard s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod ash {
        use super::*;

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ash", 0.0, 0.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ash::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ash s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ash", 300.0, 0.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ash::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ash s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ash", 0.0, 20.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ash::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ash s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ash", 500.0, 30.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ash::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ash s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ash", 1000.0, 50.0, 0, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 2);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ash::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ash s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ash", 0.0, 0.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ash::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ash s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ash", 300.0, 0.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ash::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ash s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ash", 0.0, 20.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ash::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ash s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ash", 500.0, 30.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ash::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ash s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Ash", 1000.0, 50.0, 1, 2) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 2);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Ash::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Ash s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod conviction {
        use super::*;

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Conviction", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Conviction::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Conviction s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Conviction", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Conviction::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Conviction s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Conviction", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Conviction::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Conviction s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Conviction", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Conviction::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Conviction s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Conviction", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Conviction::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Conviction s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Conviction", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Conviction::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Conviction s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Conviction", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Conviction::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Conviction s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Conviction", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Conviction::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Conviction s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Conviction", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Conviction::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Conviction s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Conviction", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Conviction::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Conviction s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod phantom {
        use super::*;

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Phantom", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Phantom::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Phantom s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Phantom", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Phantom::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Phantom s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Phantom", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Phantom::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Phantom s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Phantom", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Phantom::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Phantom s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Phantom", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Phantom::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Phantom s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Phantom", 0.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Phantom::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Phantom s3 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Phantom", 300.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Phantom::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Phantom s3 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Phantom", 0.0, 20.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Phantom::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Phantom s3 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Phantom", 500.0, 30.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Phantom::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Phantom s3 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Phantom", 1000.0, 50.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Phantom::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Phantom s3 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Phantom", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Phantom::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Phantom s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Phantom", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Phantom::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Phantom s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Phantom", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Phantom::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Phantom s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Phantom", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Phantom::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Phantom s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Phantom", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Phantom::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Phantom s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod aak {
        use super::*;

        #[test]
        fn test_s3_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Aak", 0.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Aak::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Aak s3 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Aak", 300.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Aak::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Aak s3 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Aak", 0.0, 20.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Aak::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Aak s3 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Aak", 500.0, 30.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Aak::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Aak s3 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Aak", 1000.0, 50.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Aak::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Aak s3 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Aak", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Aak::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Aak s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Aak", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Aak::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Aak s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Aak", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Aak::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Aak s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Aak", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Aak::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Aak s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Aak", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Aak::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Aak s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod stainless {
        use super::*;

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Stainless", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Stainless::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Stainless s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Stainless", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Stainless::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Stainless s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Stainless", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Stainless::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Stainless s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Stainless", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Stainless::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Stainless s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Stainless", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Stainless::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Stainless s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Stainless", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Stainless::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Stainless s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Stainless", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Stainless::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Stainless s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Stainless", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Stainless::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Stainless s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Stainless", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Stainless::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Stainless s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Stainless", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Stainless::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Stainless s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Stainless", 0.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Stainless::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Stainless s3 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Stainless", 300.0, 0.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Stainless::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Stainless s3 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Stainless", 0.0, 20.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Stainless::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Stainless s3 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Stainless", 500.0, 30.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Stainless::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Stainless s3 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s3_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Stainless", 1000.0, 50.0, 2, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(2, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Stainless::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Stainless s3 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod warmy {
        use super::*;

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Warmy", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Warmy::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Warmy s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Warmy", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Warmy::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Warmy s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Warmy", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Warmy::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Warmy s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Warmy", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Warmy::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Warmy s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Warmy", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Warmy::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Warmy s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Warmy", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Warmy::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Warmy s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Warmy", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Warmy::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Warmy s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Warmy", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Warmy::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Warmy s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Warmy", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Warmy::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Warmy s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Warmy", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Warmy::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Warmy s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

    mod blitz {
        use super::*;

        #[test]
        fn test_s2_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Blitz", 0.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Blitz::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Blitz s2 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Blitz", 300.0, 0.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Blitz::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Blitz s2 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Blitz", 0.0, 20.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Blitz::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Blitz s2 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Blitz", 500.0, 30.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Blitz::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Blitz s2 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s2_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Blitz", 1000.0, 50.0, 1, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(1, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Blitz::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Blitz s2 def=1000 res=50")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Blitz", 0.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Blitz::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Blitz s1 def=0 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def300_res0() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Blitz", 300.0, 0.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(300.0, 0.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Blitz::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Blitz s1 def=300 res=0")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def0_res20() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Blitz", 0.0, 20.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(0.0, 20.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Blitz::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Blitz s1 def=0 res=20")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def500_res30() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Blitz", 500.0, 30.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(500.0, 30.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Blitz::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Blitz s1 def=500 res=30")
                .expect("DPS comparison failed");
        }

        #[test]
        fn test_s1_def1000_res50() {
            // Get Python reference DPS
            let python_result = match get_python_dps("Blitz", 1000.0, 50.0, 0, 1) {
                Ok(r) => r,
                Err(e) => {
                    eprintln!("Python harness error: {}", e);
                    return; // Skip test if Python fails
                }
            };

            let python_dps = python_result.dps.expect("No DPS from Python");

            // Create Rust operator and calculate DPS
            let params = create_test_params(0, 1);
            let enemy = create_enemy_stats(1000.0, 50.0);

            // Create operator data from Python values
            let operator_data = OperatorData {
                atk: python_result.atk.unwrap_or(1000.0),
                attack_interval: python_result.attack_interval.unwrap_or(1.0),
                attack_speed: python_result.attack_speed.unwrap_or(100.0),
                skill_parameters: vec![vec![0.0; 10]; 3],
                talent1_parameters: vec![0.0; 10],
                talent2_parameters: vec![0.0; 10],
            };

            let operator = Blitz::new(operator_data, params);
            let rust_dps = operator.skill_dps(&enemy);

            compare_dps(rust_dps, python_dps, "Blitz s1 def=1000 res=50")
                .expect("DPS comparison failed");
        }

    }

}
